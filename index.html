<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-18XR8R8MFP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-18XR8R8MFP');
</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Multi-Activity Countdown Timer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            transition: all 0.3s ease;
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.05) 0%, transparent 70%);
            animation: float 10s ease-in-out infinite;
            z-index: -1;
        }

        @keyframes float {
            0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
            50% { transform: translate(-50%, -50%) rotate(180deg); }
        }

        body.dark-mode {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }

        body.dark-mode .main-container {
            background: #1e1e2e;
            box-shadow: 0 25px 60px rgba(0,0,0,0.4);
        }

        body.dark-mode .header {
            background: linear-gradient(45deg, #2c3e50 0%, #34495e 100%);
        }

        body.dark-mode .section {
            background: #252535;
            color: #e0e0e0;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        body.dark-mode .section::before {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
        }

        body.dark-mode .activity-key {
            background: #252535;
            color: #e0e0e0;
        }

        body.dark-mode .stats-panel {
            background: #252535;
            color: #e0e0e0;
        }

        body.dark-mode .stat-card {
            background: #2a2a3e;
            border: 1px solid #3a3a4e;
        }

        body.dark-mode .stat-value {
            color: #4facfe;
        }

        body.dark-mode .stat-label {
            color: #b0b0b0;
        }

        body.dark-mode h3 {
            color: #e0e0e0;
        }

        body.dark-mode p {
            color: #b0b0b0;
        }

        body.dark-mode table {
            color: #e0e0e0;
        }

        body.dark-mode th {
            background: #2a2a3e;
            color: #4facfe;
        }

        body.dark-mode td {
            background: #252535;
            border-color: #3a3a4e;
        }

        body.dark-mode tr:hover td {
            background: #2a2a3e;
        }

        body.dark-mode button {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        body.dark-mode .btn-secondary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        body.dark-mode .btn-danger {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
        }

        body.dark-mode #activityLabel {
            background: rgba(79, 172, 254, 0.2);
            color: #e0e0e0;
            border-color: #4facfe;
        }

        body.dark-mode #digitalTimer {
            color: #4facfe;
        }

        body.dark-mode .next-activity {
            background: rgba(79, 172, 254, 0.1);
            color: #e0e0e0;
            border-color: #4facfe;
        }

        body.dark-mode .clock-container {
            background: linear-gradient(135deg, #2a2a3e 0%, #1e1e2e 100%);
        }

        body.dark-mode .focus-toggle {
            background: rgba(79, 172, 254, 0.2);
            color: #e0e0e0;
        }

        body.dark-mode .timer-badge {
            background: rgba(79, 172, 254, 0.3);
        }

        body.dark-mode #insights-list > div {
            background: linear-gradient(135deg, #2a2a3e 0%, #1e1e2e 100%) !important;
            color: #e0e0e0 !important;
            border-left-color: #4facfe !important;
        }

        /* Collapse header when timer is running or in focus mode */
        body.timer-running .header,
        body.focus-mode .header {
            padding: 20px 15px;
            transition: all 0.3s ease;
        }

        body.timer-running .header h2,
        body.focus-mode .header h2 {
            font-size: 1.8rem;
            margin-bottom: 5px;
        }

        body.timer-running .header-subtitle,
        body.focus-mode .header-subtitle {
            font-size: 0.9rem;
        }

        body.timer-running .timer-badge,
        body.focus-mode .timer-badge {
            font-size: 0.85rem;
            padding: 8px 15px;
        }

        /* Fix timer badge positioning on mobile */
        @media screen and (max-width: 600px) {
            .timer-badge {
                position: static;
                display: inline-block;
                margin: 0 auto 15px;
            }

            .header {
                text-align: center;
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            body.timer-running .header,
            body.focus-mode .header {
                padding: 15px 10px;
            }

            body.timer-running .header h2,
            body.focus-mode .header h2 {
                font-size: 1.5rem;
                margin-bottom: 5px;
            }

            body.timer-running .header-subtitle,
            body.focus-mode .header-subtitle {
                font-size: 0.8rem;
            }
        }

        body.focus-mode .non-essential {
            display: none !important;
        }

        body.focus-mode .main-container {
            max-width: 1200px;
        }

        body.focus-mode .main-content {
            grid-template-columns: 1fr;
            max-width: 900px;
            margin: 0 auto;
            padding: 30px;
        }

        body.focus-mode .clock-container {
            max-width: 500px;
            max-height: 500px;
            margin: 20px auto;
        }

        body.focus-mode #digitalTimer {
            font-size: 3.5rem;
        }

        body.focus-mode #activityLabel {
            font-size: 1.6em;
            padding: 15px 25px;
            margin: 20px auto;
        }

        body.focus-mode .controls {
            max-width: 600px;
            margin: 25px auto;
            gap: 8px;
        }

        body.focus-mode .controls button {
            padding: 12px 20px;
            font-size: 1rem;
            min-width: 100px;
        }

        body.focus-mode .focus-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            opacity: 0.8;
        }

        body.focus-mode .focus-toggle:hover {
            opacity: 1;
        }

        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 25px;
            box-shadow: 0 25px 60px rgba(0,0,0,0.15);
            overflow: hidden;
            animation: slideUp 0.8s ease-out;
            position: relative;
        }

        @keyframes slideUp {
            from { transform: translateY(40px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .header {
            background: linear-gradient(45deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 40px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: headerFloat 8s ease-in-out infinite;
        }

        @keyframes headerFloat {
            0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
            50% { transform: translate(-50%, -50%) rotate(90deg); }
        }

        .header h2 {
            font-size: 3rem;
            margin-bottom: 15px;
            font-weight: 700;
            position: relative;
            z-index: 2;
            text-shadow: 0 4px 15px rgba(0,0,0,0.2);
            animation: pulse 3s infinite;
        }

        .header-subtitle {
            font-size: 1.3rem;
            opacity: 0.9;
            position: relative;
            z-index: 2;
        }

        .timer-badge {
            position: absolute;
            top: 25px;
            right: 25px;
            background: rgba(255,255,255,0.2);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.1);
            z-index: 3;
            font-weight: 600;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .main-content {
            display: block; max-width: 1200px; margin: 0 auto;
            
            
            padding: 50px;
        }

        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }


        .section {
            background: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .section:hover {
            transform: translateY(-2px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.15);
        }

        .section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            background: linear-gradient(45deg, #4facfe, #00f2fe);
        }

        .clock-container {
            width: 90vw;
            max-width: 400px;
            height: 90vw;
            max-height: 400px;
            position: relative;
            margin: 30px auto;
            transition: all 0.3s ease;
            border-radius: 50%;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }

        #analogClock {
            width: 100%;
            height: 100%;
            border: 8px solid transparent;
            border-radius: 50%;
            background: linear-gradient(white, white) padding-box,
                        linear-gradient(45deg, #4facfe, #00f2fe) border-box;
            box-shadow: inset 0 0 30px rgba(79, 172, 254, 0.1);
        }

        body.dark-mode #analogClock {
            background: linear-gradient(#333, #333) padding-box,
                        linear-gradient(45deg, #4facfe, #00f2fe) border-box;
            box-shadow: inset 0 0 30px rgba(79, 172, 254, 0.2);
        }

        .toggle-container {
            display: flex;
            gap: 30px;
            justify-content: center;
            align-items: center;
            background: white;
            padding: 20px 30px;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        body.dark-mode .toggle-container {
            background: #333;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }

        .toggle-item {
            display: flex;
            align-items: center;
            gap: 10px;
            position: relative;
        }

        .toggle-item input[type="checkbox"] {
            appearance: none;
            width: 50px;
            height: 26px;
            background: #ddd;
            border-radius: 13px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .toggle-item input[type="checkbox"]:checked {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
        }

        .toggle-item input[type="checkbox"]::before {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .toggle-item input[type="checkbox"]:checked::before {
            left: 26px;
        }

        .toggle-item label {
            font-weight: 600;
            color: #333;
            cursor: pointer;
        }

        body.dark-mode .toggle-item label {
            color: #fff;
        }

        #activityLabel {
            font-weight: bold;
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            padding: 15px 25px;
            display: inline-block;
            border-radius: 15px;
            font-size: 1.3rem;
            margin: 20px auto;
            text-align: center;
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.3);
            transition: all 0.3s ease;
            animation: labelGlow 2s ease-in-out infinite alternate;
        }

        @keyframes labelGlow {
            from { box-shadow: 0 8px 25px rgba(255, 215, 0, 0.3); }
            to { box-shadow: 0 12px 35px rgba(255, 215, 0, 0.5); }
        }

        #digitalTimer {
            font-size: 3rem;
            font-weight: 700;
            color: #667eea;
            text-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            margin: 20px 0;
            text-align: center;
            transition: all 0.3s ease;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            margin: 20px 0;
        }

        .controls button, .feature-container button {
            padding: 10px 16px;
            border: none;
            border-radius: 12px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            min-width: 90px;
        }

        .controls button::before, .feature-container button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s ease;
        }

        .controls button:hover::before, .feature-container button:hover::before {
            left: 100%;
        }

        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #84fab0, #8fd3f4);
            color: white;
            box-shadow: 0 8px 25px rgba(132, 250, 176, 0.3);
        }

        .btn-secondary:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(132, 250, 176, 0.4);
        }

        .btn-danger {
            background: linear-gradient(45deg, #ff4757, #ff6b7a);
            color: white;
            box-shadow: 0 8px 25px rgba(255, 71, 87, 0.3);
        }

        .btn-danger:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(255, 71, 87, 0.4);
        }

        .feature-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            margin: 20px 0;
        }

        .activity-key {
            margin-top: 30px;
            padding: 30px;
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .activity-key h3 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.5rem;
            text-align: center;
        }

        .activity-key table {
            border-collapse: collapse;
            width: 100%;
            margin: auto;
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .activity-key th {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 15px;
            font-weight: 600;
            text-align: left;
        }

        .activity-key td {
            padding: 12px 15px;
            border-bottom: 1px solid #f0f0f0;
            transition: all 0.3s ease;
        }

        .activity-key tr:hover td {
            background: linear-gradient(135deg, #f8f9ff 0%, #e8f4fd 100%);
        }

        .color-box {
            width: 25px;
            height: 25px;
            display: inline-block;
            cursor: pointer;
            border-radius: 8px;
            border: 2px solid white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }

        .color-box:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .draggable-row {
            cursor: move;
            transition: all 0.3s ease;
        }

        .draggable-row.dragging {
            opacity: 0.7;
            transform: scale(1.02);
            background: linear-gradient(135deg, #f8f9ff 0%, #e8f4fd 100%);
        }

        .drag-handle {
            cursor: move;
            padding: 8px;
            user-select: none;
            color: #667eea;
            font-size: 1.2rem;
            transition: all 0.3s ease;
        }

        .drag-handle:hover {
            color: #4facfe;
            transform: scale(1.1);
        }

        .drag-handle::before {
            content: "☰";
        }

        .focus-toggle {
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: none;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: white;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 100;
        }

        .focus-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 12px 35px rgba(102, 126, 234, 0.4);
        }

        .next-activity {
            padding: 15px 25px;
            border-radius: 15px;
            margin: 20px auto;
            display: inline-block;
            font-weight: bold;
            background: linear-gradient(45deg, #84fab0, #8fd3f4);
            color: white;
            box-shadow: 0 8px 25px rgba(132, 250, 176, 0.3);
            transition: all 0.3s ease;
            opacity: 0;
            text-align: center;
        }

        body.focus-mode .next-activity {
            opacity: 1;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: white;
            margin: 5% auto;
            padding: 40px;
            border: none;
            width: 90%;
            max-width: 700px;
            border-radius: 25px;
            box-shadow: 0 25px 60px rgba(0,0,0,0.3);
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from { opacity: 0; transform: translateY(-50px); }
            to { opacity: 1; transform: translateY(0); }
        }

        body.dark-mode .modal-content {
            background: #333;
            color: white;
        }

        .close-button {
            color: #aaa;
            float: right;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .close-button:hover {
            color: #ff4757;
            transform: scale(1.1);
        }

        /* Progress Indicators */
        .progress-container {
            background: #f0f0f0;
            height: 15px;
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.1);
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            border-radius: 10px;
            transition: width 0.5s ease;
            box-shadow: 0 2px 10px rgba(79, 172, 254, 0.4);
        }

        /* Notification Styles */
        .notification {
            position: fixed;
            top: 30px;
            right: 30px;
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
            padding: 20px 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(79, 172, 254, 0.4);
            transform: translateX(400px);
            transition: transform 0.3s ease;
            z-index: 1001;
            font-weight: 600;
            max-width: 300px;
        }

        .notification.show {
            transform: translateX(0);
        }

        /* Statistics Panel */
        .stats-panel {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 20px;
            margin-bottom: 25px;
            position: relative;
            overflow: hidden;
        }

        .stats-panel::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: rotate 12s linear infinite;
        }

        @keyframes rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            position: relative;
            z-index: 2;
        }

        .stat-card {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.1);
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #00f2fe;
            text-shadow: 0 2px 10px rgba(0, 242, 254, 0.3);
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.9;
            margin-top: 5px;
        }

        /* Responsive Design */
        @media screen and (max-width: 768px) {
            .main-content {
                padding: 25px;
            }
            
            /* Fix clock container to be fully visible on mobile */
            .clock-container {
                width: 85vw;
                max-width: 350px;
                height: 85vw;
                max-height: 350px;
                padding: 15px;
                margin: 20px auto;
            }
            
            /* Fix toggle container for mobile - stack vertically */
            .toggle-container {
                flex-direction: column;
                gap: 15px;
                padding: 20px 15px;
                align-items: stretch;
            }
            
            .toggle-item {
                justify-content: space-between;
                width: 100%;
            }
            
            .toggle-item label {
                font-size: 0.95rem;
                white-space: nowrap;
            }
            
            
            .header h2 {
                font-size: 2rem;
            }
            
            #digitalTimer {
                font-size: 2.5rem;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .controls button, .feature-container button {
                width: 100%;
                max-width: 300px;
            }
            
            .modal-content {
                width: 95%;
                margin: 10% auto;
                padding: 25px;
            }
            
            body.focus-mode #digitalTimer {
                font-size: 3rem;
            }
        }

        /* Enhanced mobile responsiveness */
        @media screen and (max-width: 600px) {
            body {
                padding: 10px;
            }
            .main-container {
                border-radius: 15px;
                box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            }
            .header {
                padding: 25px 15px;
            }
            .main-content {
                padding: 15px;
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            .section {
                width: 100%;
            }
            .clock-container {
                width: 82vw;
                max-width: 82vw;
                height: 82vw;
                max-height: 82vw;
                padding: 5px;
                margin: 15px auto;
                box-sizing: border-box;
                overflow: visible;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            #analogClock {
                width: 100%;
                height: 100%;
                display: block;
                margin: 0 auto;
            }
            #digitalTimer {
                font-size: 1.8rem;
            }
            #activityLabel {
                font-size: 1.1rem;
                padding: 10px 20px;
            }
            .controls {
                flex-direction: column;
                gap: 10px;
            }
            .controls button {
                width: 100%;
                font-size: 0.9rem;
                padding: 12px;
            }
            .toggle-container {
                flex-direction: column;
            }
            .modal-content {
                width: 95%;
                padding: 15px;
            }
            .stats-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }
        }

        .hidden {
            display: none;
        }

        /* Sound and color palette styles remain the same but with enhanced gradients */
        .color-palette {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }

        .color-option {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .color-option:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .color-option.selected {
            border: 3px solid #667eea;
            transform: scale(1.15);
        }

        .sound-option {
            display: flex;
            align-items: center;
            padding: 15px;
            margin: 10px 0;
            border: 2px solid #f0f0f0;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
        }

        .sound-option:hover {
            background: linear-gradient(135deg, #f8f9ff 0%, #e8f4fd 100%);
            border-color: #4facfe;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(79, 172, 254, 0.2);
        }

        .sound-option.selected {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="header">
            <h2>🎯 MyTimer.io</h2>
            <p class="header-subtitle">Multi-Activity Timer | Increased Awareness | Productivity</p>
        </div>

        <div class="main-content">
            <div class="left-panel">
                <div class="toggle-container non-essential">
                    <div class="toggle-item">
                        <input type="checkbox" id="darkModeToggle">
                        <label for="darkModeToggle">Dark Mode</label>
                    </div>
                    <div class="toggle-item">
                        <input type="checkbox" id="realTimeClockToggle" checked>
                        <label for="realTimeClockToggle">Real-Time Clock</label>
                    </div>
                    <div class="toggle-item">
                        <input type="checkbox" id="fixedStartToggle">
                        <label for="fixedStartToggle">Fixed 12 O'Clock Start</label>
                    </div>
                </div>

                <div class="section">
                    <div class="clock-container">
                        <canvas id="analogClock"></canvas>
                    </div>
                    
                    <p id="activityLabel">No Activities Started</p>
                    <p id="digitalTimer" aria-live="polite"></p>
                    
                    <div id="nextActivityContainer" class="next-activity" style="display: none;">
                        Next: <span id="nextActivityLabel"></span>
                    </div>

                    <div id="totalTimeContainer" class="non-essential" style="font-weight: bold; margin: 20px 0; display: none; text-align: center; color: #667eea;"></div>
                    <div id="endTimeContainer" class="non-essential" style="font-style: italic; margin-bottom: 20px; display: none; text-align: center; color: #666;"></div>
                    <div class="progress-container non-essential" style="display: none;">
                        <div id="overallProgressBar" class="progress-bar" style="width: 0%;"></div>
                    </div>
                </div>

                <div class="controls">
                    <button onclick="addActivity()" class="non-essential btn-primary" aria-label="Add Activity">➕ Add Activity</button>
                    <button onclick="startTimer()" id="startBtn" class="btn-primary" aria-label="Start Timer">🚀 START</button>
                    <button onclick="pauseTimer()" id="pauseBtn" class="btn-secondary" aria-label="Pause Timer">⏸️ Pause</button>
                    <button onclick="resumeTimer()" id="resumeBtn" style="display:none;" class="btn-primary" aria-label="Resume Timer">▶️ Resume</button>
                    <button onclick="resetTimer()" class="btn-danger" aria-label="Reset Timer">🔄 Reset</button>
                    <button onclick="skipToNext()" id="skipBtn" style="display:none;" class="btn-secondary" aria-label="Skip to Next">⏭️ Skip</button>
                </div>
                
                <div class="feature-container non-essential">
                    <button onclick="openPresetsModal()" class="btn-primary" aria-label="Manage Presets">📋 Presets</button>
                    <button onclick="openColorModal()" class="btn-secondary" aria-label="Choose Colors">🎨 Colors</button>
                    <button onclick="openSoundModal()" class="btn-primary" aria-label="Select Sounds">🔊 Sounds</button>
                    <button onclick="exportActivities()" class="btn-secondary" aria-label="Export Activities">📤 Export</button>
                    <button onclick="importActivities()" class="btn-primary" aria-label="Import Activities">📥 Import</button>
                </div>

                <div class="activity-key non-essential" id="activityKey" aria-label="Activity List">
                    <h3>Activity Timeline</h3>
                    <p style="text-align: center; color: #666; margin-bottom: 20px;">Add activities to see your personalized schedule</p>
                </div>

                <div id="undoBanner" class="non-essential" style="display: none; background: linear-gradient(45deg, #ffd700, #ffed4e); padding: 15px; border-radius: 15px; text-align: center; box-shadow: 0 8px 25px rgba(255, 215, 0, 0.3);">
                    Activity deleted. <button onclick="undoDelete()" class="btn-primary" style="margin-left: 10px;">Undo</button>
                </div>

                <!-- Statistics Panel -->
                <div class="stats-panel section non-essential">
                    <h3 style="margin-bottom: 20px; position: relative; z-index: 2;">📊 Session Stats</h3>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-value" id="totalActivities">0</div>
                            <div class="stat-label">Total Activities</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="completedCount">0</div>
                            <div class="stat-label">Completed</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="totalPlannedTime">0m</div>
                            <div class="stat-label">Planned Time</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="progressStat">0%</div>
                            <div class="stat-label">Progress</div>
                        </div>
                    </div>
                </div>

                <!-- Quick Insights -->
                <div class="section non-essential" style="background: white; border: 2px solid #e1e5e9; border-radius: 20px; padding: 25px; margin-bottom: 25px;">
                    <h3 style="color: #333; margin-bottom: 20px; display: flex; align-items: center; gap: 10px;">
                        🧠 Smart Insights
                    </h3>
                    <div id="insights-list">
                        <div style="padding: 15px; background: linear-gradient(135deg, #f8f9ff 0%, #e8f4fd 100%); margin-bottom: 12px; border-radius: 12px; border-left: 4px solid #4facfe; font-size: 0.95rem;">
                            🎯 Perfect timing to start your focused work session!
                        </div>
                        <div style="padding: 15px; background: linear-gradient(135deg, #f8f9ff 0%, #e8f4fd 100%); margin-bottom: 12px; border-radius: 12px; border-left: 4px solid #4facfe; font-size: 0.95rem;">
                            ⚡ Your productivity peaks with timed activities.
                        </div>
                        <div style="padding: 15px; background: linear-gradient(135deg, #f8f9ff 0%, #e8f4fd 100%); margin-bottom: 12px; border-radius: 12px; border-left: 4px solid #4facfe; font-size: 0.95rem;">
                            📈 Break tasks into 25-minute focused sessions.
                        </div>
                    </div>
                </div>

                <!-- Quick Actions -->
                <div class="section non-essential" style="display: grid; gap: 15px;">
                    <button onclick="showSummary()" class="btn-primary" style="width: 100%;">
                        📊 Session Summary
                    </button>
                    <button onclick="saveActivities()" class="btn-secondary" style="width: 100%;">
                        💾 Save Session
                    </button>
                    <button onclick="loadActivities()" class="btn-primary" style="width: 100%;">
                        📂 Load Session
                    </button>
                </div>
            </div>

        </div>
    </div>

    <div class="focus-toggle" onclick="toggleFocusMode()" title="Toggle Focus Mode">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"></path>
            <circle cx="12" cy="12" r="3"></circle>
        </svg>
    </div>

    <!-- Modals -->
    <div id="colorModal" class="modal non-essential">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('colorModal')">&times;</span>
            <h3 style="margin-bottom: 25px; color: #333;">🎨 Color Theme Selection</h3>
            <div style="margin-bottom: 20px;">
                <label for="harmonyType" style="font-weight: 600; margin-right: 10px;">Color Harmony: </label>
                <select id="harmonyType" onchange="generateColorPalette()" style="padding: 8px 12px; border-radius: 8px; border: 2px solid #e1e5e9;">
                    <option value="monochromatic">Monochromatic</option>
                    <option value="analogous">Analogous</option>
                    <option value="complementary">Complementary</option>
                    <option value="splitComplementary">Split Complementary</option>
                    <option value="triadic">Triadic</option>
                    <option value="tetradic">Tetradic</option>
                </select>
            </div>
            <div style="margin-bottom: 20px;">
                <label for="baseColor" style="font-weight: 600; margin-right: 10px;">Base Color: </label>
                <input type="color" id="baseColor" value="#3366ff" onchange="generateColorPalette()" style="width: 50px; height: 40px; border: none; border-radius: 8px; cursor: pointer;">
            </div>
            <div class="color-palette" id="colorPalette"></div>
        </div>
    </div>

    <div id="soundModal" class="modal non-essential">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('soundModal')">&times;</span>
            <h3 style="margin-bottom: 25px; color: #333;">🔊 Sound Selection</h3>
            <p style="margin-bottom: 20px; color: #666;">Choose a sound to play when an activity completes:</p>
            <div id="soundList"></div>
        </div>
    </div>

    <div id="presetsModal" class="modal non-essential">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('presetsModal')">&times;</span>
            <h3 style="margin-bottom: 25px; color: #333;">📋 Preset Management</h3>
            <p style="margin-bottom: 20px; color: #666;">Save your current activities as a preset or load a previously saved preset:</p>
            
            <div style="margin-bottom: 25px;">
                <input type="text" id="newPresetName" placeholder="Preset Name (e.g. Morning Routine)" style="padding: 12px 16px; width: 70%; border: 2px solid #e1e5e9; border-radius: 10px; margin-right: 10px;">
                <button onclick="saveAsPreset()" class="btn-primary">Save Current as Preset</button>
            </div>
            
            <h4 style="margin-bottom: 15px; color: #333;">Available Presets</h4>
            <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 15px;" id="presetContainer">
                <p id="noPresetsMessage" style="color: #666; text-align: center;">No saved presets found.</p>
            </div>
        </div>
    </div>

    <!-- Session Summary Modal -->
    <div id="summaryModal" class="modal non-essential">
        <div class="modal-content">
            <span class="close-button" onclick="document.getElementById('summaryModal').style.display='none'">&times;</span>
            <h3 style="margin-bottom: 25px; color: #333;">📊 Session Summary</h3>
            <ul id="summaryList" style="list-style: none; padding: 0;"></ul>
            <canvas id="summaryChart" style="max-width: 100%; height: 300px; margin: 30px auto; display: block; border-radius: 15px;"></canvas>
            <div style="display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; margin-top: 25px;">
                <button id="exportSummaryBtn" class="btn-primary">📤 Export Summary</button>
                <button id="saveChartBtn" class="btn-secondary">🖼️ Save Chart</button>
                <button id="printSummaryBtn" class="btn-primary">🖨️ Print Summary</button>
            </div>
        </div>
    </div>

    <div class="notification" id="notification">
        ⏰ Timer completed! Time for a break!
    </div>

    <!-- Audio elements -->
    <audio id="chimeSound" src="https://actions.google.com/sounds/v1/alarms/digital_watch_alarm_long.ogg"></audio>
    <audio id="bellSound" src="https://actions.google.com/sounds/v1/alarms/medium_bell_ringing_near.ogg"></audio>
    <audio id="beepSound" src="https://actions.google.com/sounds/v1/alarms/beep_short.ogg"></audio>
    <audio id="alarmSound" src="https://actions.google.com/sounds/v1/alarms/alarm_clock.ogg"></audio>
    <audio id="notificationSound" src="https://actions.google.com/sounds/v1/alarms/notification_alert_chord.ogg"></audio>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        // Constants
        const DEFAULT_COLORS = ["#3366ff", "#33cc33", "#ff6600", "#9933cc", "#cc3366", "#33cccc"];
        
        // Global variables
        let activities = [];
        let currentActivityIndex = 0;
        let timerInterval;
        let isRunning = false;
        let paused = false;
        let pausedRemaining = 0;
        let canvas, ctx, radius;
        let selectedSound = "chimeSound";
        let colorPalette = [...DEFAULT_COLORS];
        let dragStartIndex;
        let inFocusMode = false;
        let startingAngleOffset = 0;
        let totalElapsedTime = 0;
        let clockAnimationFrame;
        let showRealTimeClock = true;
        let useFixedStartPosition = false;
        let lastDeletedActivity = null;

        document.addEventListener("DOMContentLoaded", () => {
            initializeCanvas();
            setupEventListeners();
            loadSavedSettings();
            populateSoundOptions();
            generateColorPalette();
            startRealTimeClock();
            updateStats();
            
            if (localStorage.getItem("activities")) {
                loadActivities();
            }
        });

        function setupEventListeners() {
            document.getElementById("darkModeToggle").addEventListener("change", toggleDarkMode);
            document.getElementById("realTimeClockToggle").addEventListener("change", toggleRealTimeClock);
            document.getElementById("fixedStartToggle").addEventListener("change", toggleFixedStartPosition);
        }

        function loadSavedSettings() {
            if (localStorage.getItem("darkMode") === "true") {
                document.getElementById("darkModeToggle").checked = true;
                document.body.classList.add("dark-mode");
            }
            
            if (localStorage.getItem("focusMode") === "true") {
                inFocusMode = true;
                document.body.classList.add("focus-mode");
            }
            
            if (localStorage.getItem("showRealTimeClock") === "false") {
                showRealTimeClock = false;
                document.getElementById("realTimeClockToggle").checked = false;
            }
            
            if (localStorage.getItem("useFixedStartPosition") === "true") {
                useFixedStartPosition = true;
                document.getElementById("fixedStartToggle").checked = true;
            }
            
            if (localStorage.getItem("selectedSound")) {
                selectedSound = localStorage.getItem("selectedSound");
            }
            
            if (localStorage.getItem("colorPalette")) {
                try {
                    colorPalette = JSON.parse(localStorage.getItem("colorPalette"));
                } catch (e) {
                    colorPalette = [...DEFAULT_COLORS];
                }
            }
        }

        function initializeCanvas() {
            canvas = document.getElementById("analogClock");
            resizeCanvas();
            ctx = canvas.getContext("2d");
            radius = canvas.width / 2;
            ctx.translate(radius, radius);
            window.addEventListener('resize', resizeCanvas);
            updateClockDisplay();
        }

        function resizeCanvas() {
            const container = document.querySelector('.clock-container');
            const isMobile = window.innerWidth <= 600;
            const buffer = isMobile ? 16 : 40;
            const size = Math.min(container.clientWidth - buffer, container.clientHeight - buffer);
            canvas.width = size;
            canvas.height = size;
            if (ctx) {
                radius = canvas.width / 2;
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.translate(radius, radius);
            }
        }

        function toggleDarkMode(e) {
            document.body.classList.toggle("dark-mode", e.target.checked);
            localStorage.setItem("darkMode", e.target.checked);
            updateClockDisplay();
        }
        
        function toggleFocusMode() {
            inFocusMode = !inFocusMode;
            document.body.classList.toggle("focus-mode", inFocusMode);
            localStorage.setItem("focusMode", inFocusMode);
            updateNextActivityIndicator();
            
            setTimeout(() => {
                resizeCanvas();
                updateClockDisplay();
            }, 300);
        }

        function toggleRealTimeClock() {
            showRealTimeClock = !showRealTimeClock;
            localStorage.setItem("showRealTimeClock", showRealTimeClock);
            updateClockDisplay();
            document.getElementById("realTimeClockToggle").checked = showRealTimeClock;
        }

        function toggleFixedStartPosition() {
            useFixedStartPosition = document.getElementById("fixedStartToggle").checked;
            localStorage.setItem("useFixedStartPosition", useFixedStartPosition);
            updateClockDisplay();
            
            if (isRunning) {
                const activity = activities[currentActivityIndex];
                const progress = (activity.duration * 60 - activity.remainingTime) / (activity.duration * 60);
                updateClockDisplay(progress);
            }
        }
        
        function updateNextActivityIndicator() {
            const nextActivityContainer = document.getElementById("nextActivityContainer");
            
            if (isRunning && inFocusMode && currentActivityIndex < activities.length - 1) {
                const nextActivity = activities[currentActivityIndex + 1];
                document.getElementById("nextActivityLabel").innerText = `${nextActivity.name} (${nextActivity.duration}m)`;
                document.getElementById("nextActivityLabel").style.backgroundColor = nextActivity.color;
                nextActivityContainer.style.display = "inline-block";
            } else {
                nextActivityContainer.style.display = "none";
            }
        }

        function drawClockBase() {
            ctx.beginPath();
            ctx.arc(0, 0, radius - 10, 0, 2 * Math.PI);
            ctx.fillStyle = document.body.classList.contains("dark-mode") ? "#333" : "white";
            ctx.fill();
            ctx.lineWidth = 3;
            ctx.strokeStyle = document.body.classList.contains("dark-mode") ? "#4facfe" : "#667eea";
            ctx.stroke();
        }

        function drawClockNumbers() {
            ctx.font = radius * 0.12 + "px 'Segoe UI', sans-serif";
            ctx.fillStyle = document.body.classList.contains("dark-mode") ? "white" : "#333";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fontWeight = "600";
            
            for (let i = 1; i <= 12; i++) {
                let angle = (i * 30) * (Math.PI / 180);
                let x = Math.cos(angle - Math.PI / 2) * (radius - 35);
                let y = Math.sin(angle - Math.PI / 2) * (radius - 35);
                ctx.fillText(i, x, y);
            }
        }

        function drawMinuteHashes() {
            ctx.strokeStyle = document.body.classList.contains("dark-mode") ? "#4facfe" : "#667eea";
            ctx.lineWidth = 1;
            
            for (let i = 0; i < 60; i++) {
                let angle = i * 6 * (Math.PI / 180);
                let isHour = i % 5 === 0;
                let innerRadius = radius - (isHour ? 25 : 15);
                let outerRadius = radius - 10;
                
                let x1 = Math.cos(angle - Math.PI / 2) * innerRadius;
                let y1 = Math.sin(angle - Math.PI / 2) * innerRadius;
                let x2 = Math.cos(angle - Math.PI / 2) * outerRadius;
                let y2 = Math.sin(angle - Math.PI / 2) * outerRadius;
                
                ctx.lineWidth = isHour ? 2 : 1;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        }
        
        function drawRealTimeClock() {
            const now = new Date();
            const hours = now.getHours() % 12;
            const minutes = now.getMinutes();
            const seconds = now.getSeconds();
            const milliseconds = now.getMilliseconds();
            
            const smoothMinutes = minutes + (seconds / 60) + (milliseconds / 60000);
            const smoothHours = hours + (smoothMinutes / 60);
            
            // Hour hand
            ctx.strokeStyle = document.body.classList.contains("dark-mode") ? "#fff" : "#333";
            ctx.lineWidth = 6;
            ctx.lineCap = "round";
            ctx.beginPath();
            const hourAngle = smoothHours * 30 * (Math.PI / 180);
            ctx.moveTo(0, 0);
            ctx.lineTo(
                Math.cos(hourAngle - Math.PI / 2) * (radius * 0.5),
                Math.sin(hourAngle - Math.PI / 2) * (radius * 0.5)
            );
            ctx.stroke();
            
            // Minute hand
            ctx.lineWidth = 4;
            ctx.beginPath();
            const minuteAngle = smoothMinutes * 6 * (Math.PI / 180);
            ctx.moveTo(0, 0);
            ctx.lineTo(
                Math.cos(minuteAngle - Math.PI / 2) * (radius * 0.7),
                Math.sin(minuteAngle - Math.PI / 2) * (radius * 0.7)
            );
            ctx.stroke();
            
            // Second hand
            ctx.strokeStyle = "#ff4757";
            ctx.lineWidth = 2;
            ctx.beginPath();
            const secondAngle = seconds * 6 * (Math.PI / 180);
            ctx.moveTo(0, 0);
            ctx.lineTo(
                Math.cos(secondAngle - Math.PI / 2) * (radius * 0.8),
                Math.sin(secondAngle - Math.PI / 2) * (radius * 0.8)
            );
            ctx.stroke();
            
            // Center circle
            ctx.fillStyle = "#ff4757";
            ctx.beginPath();
            ctx.arc(0, 0, radius * 0.05, 0, 2 * Math.PI);
            ctx.fill();
        }

        function drawActivitySectors(currentProgress = 0) {
            if (activities.length === 0) return;
            
            let startAngle = -Math.PI / 2;
            
            if (!useFixedStartPosition && isRunning) {
                startAngle += startingAngleOffset;
            }
            
            activities.forEach((activity, index) => {
                let arcLength = (activity.duration / 60) * 2 * Math.PI;
                let endAngle = startAngle + arcLength;

                if (index === currentActivityIndex && isRunning) {
                    // Draw completed portion of current activity (darker)
                    let progressAngle = startAngle + arcLength * currentProgress;
                    
                    if (currentProgress > 0) {
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.arc(0, 0, radius - 20, startAngle, progressAngle);
                        ctx.closePath();
                        ctx.fillStyle = activity.color;
                        ctx.globalAlpha = 0.4;
                        ctx.fill();
                        ctx.globalAlpha = 1;
                        
                        // Border for completed portion
                        ctx.strokeStyle = "rgba(255,255,255,0.3)";
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                    
                    // Draw remaining portion of current activity (bright)
                    if (currentProgress < 1) {
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.arc(0, 0, radius - 20, progressAngle, endAngle);
                        ctx.closePath();
                        ctx.fillStyle = activity.color;
                        ctx.globalAlpha = 0.9;
                        ctx.fill();
                        ctx.globalAlpha = 1;
                        
                        // Border for remaining portion
                        ctx.strokeStyle = "rgba(255,255,255,0.3)";
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                } else {
                    // Draw completed or future activities
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, radius - 20, startAngle, endAngle);
                    ctx.closePath();
                    ctx.fillStyle = activity.color;
                    ctx.globalAlpha = activity.completed ? 0.3 : 0.6;
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    
                    // Add a subtle border
                    ctx.strokeStyle = "rgba(255,255,255,0.3)";
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
                
                startAngle = endAngle;
            });
        }

        function updateClockDisplay(currentProgress = 0) {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.translate(radius, radius);
            
            drawClockBase();
            drawMinuteHashes();
            drawClockNumbers();
            drawActivitySectors(currentProgress);
            
            if (showRealTimeClock) {
                drawRealTimeClock();
            }
        }
        
        function startRealTimeClock() {
            if (clockAnimationFrame) cancelAnimationFrame(clockAnimationFrame);
            
            function animateClock() {
                if (!isRunning && showRealTimeClock) {
                    updateClockDisplay();
                    clockAnimationFrame = requestAnimationFrame(animateClock);
                }
            }
            animateClock();
        }

        function playSound(soundId = selectedSound) {
            try {
                const soundElement = document.getElementById(soundId);
                if (soundElement) {
                    soundElement.currentTime = 0;
                    soundElement.play().catch(error => {
                        console.warn("Could not play sound:", error);
                    });
                    
                    setTimeout(() => {
                        if (!soundElement.paused) {
                            soundElement.pause();
                            soundElement.currentTime = 0;
                        }
                    }, 5000);
                }
            } catch (error) {
                console.error("Error playing sound:", error);
            }
        }

        function addActivity() {
            let name = prompt("Enter activity name:");
            if (!name || name.trim() === "") return;

            let durationInput = prompt("Enter duration (minutes):");
            let duration = parseInt(durationInput);
            
            if (isNaN(duration) || duration <= 0) {
                showNotification("❌ Please enter a valid positive number for duration.");
                return;
            }

            let color = colorPalette[activities.length % colorPalette.length];
            activities.push({ 
                name, 
                duration, 
                color, 
                completed: false,
                startTime: null,
                elapsedTime: 0,
                remainingTime: duration * 60
            });
            
            updateClockDisplay();
            updateActivityKey();
            updateStats();
            showNotification(`✅ Activity "${name}" added successfully!`);
        }

        function updateStats() {
            document.getElementById("totalActivities").textContent = activities.length;
            document.getElementById("completedCount").textContent = activities.filter(a => a.completed).length;
            
            const totalMinutes = activities.reduce((sum, act) => sum + act.duration, 0);
            document.getElementById("totalPlannedTime").textContent = totalMinutes + "m";
            
            
            // Calculate progress percentage
            const completedCount = activities.filter(a => a.completed).length;
            const progressPercent = activities.length > 0 ? 
                Math.round((completedCount / activities.length) * 100) : 0;
            document.getElementById("progressStat").textContent = progressPercent + "%";
        }

        function updateActivityKey() {
            let keyContainer = document.getElementById("activityKey");
            
            if (activities.length === 0) {
                keyContainer.innerHTML = `
                    <h3>Activity Timeline</h3>
                    <p style="text-align: center; color: #666; margin-bottom: 20px;">Add activities to see your personalized schedule</p>
                `;
                return;
            }
            
            keyContainer.innerHTML = `
                <h3>Activity Timeline</h3>
                <p style="text-align: center; color: #666; margin-bottom: 20px;"><small>Drag rows to reorder activities</small></p>
            `;
            
            let table = document.createElement("table");
            table.id = "activitiesTable";
            let headerRow = table.insertRow();
            headerRow.innerHTML = "<th></th><th>Color</th><th>Activity</th><th>Time (min)</th><th>Start Time</th><th>Status</th><th>Actions</th>";
            
            activities.forEach((act, i) => {
                let row = table.insertRow();
                row.classList.add("draggable-row");
                row.setAttribute("data-index", i);
                
                let dragCell = row.insertCell();
                let colorCell = row.insertCell();
                let nameCell = row.insertCell();
                let durationCell = row.insertCell();
                let startTimeCell = row.insertCell();
                let statusCell = row.insertCell();
                let actionsCell = row.insertCell();
                
                dragCell.classList.add("drag-handle");
                
                colorCell.innerHTML = `<span class='color-box' style='background:${act.color}' onclick='openColorPickerForActivity(${i})'></span>`;
                nameCell.setAttribute('contenteditable', 'true');
                nameCell.innerText = act.name;
                nameCell.addEventListener('blur', () => validateAndUpdateActivity(i, 'name', nameCell.innerText));
                
                durationCell.setAttribute('contenteditable', 'true');
                durationCell.innerText = act.duration;
                durationCell.addEventListener('blur', () => validateAndUpdateActivity(i, 'duration', durationCell.innerText));
                
                startTimeCell.id = `activity-start-time-${i}`;
                startTimeCell.innerText = act.startTime ? formatTime(act.startTime) : calculateProjectedStartTime(i);
                
                statusCell.id = `activity-status-${i}`;
                statusCell.innerText = act.completed ? "✔ Completed" : "Pending";
                
                const deleteBtn = document.createElement('button');
                deleteBtn.innerText = 'Delete';
                deleteBtn.className = 'btn-danger';
                deleteBtn.style.padding = '5px 10px';
                deleteBtn.style.fontSize = '0.8rem';
                deleteBtn.onclick = () => deleteActivity(i);
                actionsCell.appendChild(deleteBtn);
            });
            
            keyContainer.appendChild(table);
            setupDragAndDrop();
        }

        function formatTime(date) {
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }
        
        function calculateProjectedStartTime(activityIndex) {
            if (isRunning && activities[activityIndex].startTime) {
                return formatTime(activities[activityIndex].startTime);
            }
            
            const now = new Date();
            let projectedStart = new Date(now);
            
            for (let i = 0; i < activityIndex; i++) {
                projectedStart = new Date(projectedStart.getTime() + activities[i].duration * 60000);
            }
            
            return formatTime(projectedStart);
        }
        
        function validateAndUpdateActivity(index, field, value) {
            if (index >= activities.length) return;
            
            if (field === 'name') {
                if (value.trim() === '') {
                    showNotification('❌ Activity name cannot be empty');
                    updateActivityKey();
                    return;
                }
                activities[index].name = value.trim();
            } 
            else if (field === 'duration') {
                const duration = parseInt(value);
                if (isNaN(duration) || duration <= 0) {
                    showNotification('❌ Duration must be a positive number');
                    updateActivityKey();
                    return;
                }
                activities[index].duration = duration;
                if (!activities[index].startTime || activities[index].completed) {
                    activities[index].remainingTime = duration * 60;
                }
            }
            
            updateClockDisplay();
            updateNextActivityIndicator();
            updateStats();
        }
        
        function deleteActivity(index) {
            if (isRunning) {
                showNotification("⏸️ Please stop the timer before deleting activities.");
                return;
            }
            
            lastDeletedActivity = { ...activities[index], index };
            activities.splice(index, 1);
            updateActivityKey();
            updateClockDisplay();
            updateStats();
            
            const undoBanner = document.getElementById("undoBanner");
            undoBanner.style.display = "block";
            clearTimeout(undoBanner.hideTimer);
            undoBanner.hideTimer = setTimeout(() => {
                undoBanner.style.display = "none";
                lastDeletedActivity = null;
            }, 5000);
            
            if (currentActivityIndex >= index) {
                currentActivityIndex = Math.max(0, currentActivityIndex - 1);
            }
        }

        function undoDelete() {
            if (!lastDeletedActivity) return;
            activities.splice(lastDeletedActivity.index, 0, lastDeletedActivity);
            updateActivityKey();
            updateClockDisplay();
            updateStats();
            lastDeletedActivity = null;
            document.getElementById("undoBanner").style.display = "none";
        }

        function startTimer() {
            if (isRunning) return;
            if (activities.length === 0) {
                showNotification("❌ Please add at least one activity first.");
                return;
            }
            
            isRunning = true;
            document.body.classList.add('timer-running');
            document.getElementById("resumeBtn").style.display = "none";
            document.getElementById("pauseBtn").style.display = "inline-block";
            document.getElementById("skipBtn").style.display = "inline-block";
            document.getElementById("startBtn").style.display = "none";
            
            if (!useFixedStartPosition) {
                const now = new Date();
                const minutes = now.getMinutes();
                const seconds = now.getSeconds();
                startingAngleOffset = ((minutes * 60 + seconds) / 3600) * (2 * Math.PI);
            } else {
                startingAngleOffset = 0;
            }
            
            totalElapsedTime = 0;
            
            let currentStartTime = new Date();
            activities.forEach((activity, index) => {
                activity.startTime = new Date(currentStartTime);
                activity.completed = index < currentActivityIndex;
                activity.elapsedTime = 0;
                activity.remainingTime = activity.duration * 60;
                currentStartTime = new Date(currentStartTime.getTime() + activity.duration * 60000);
            });
            
            updateActivityKey();
            updateTotalTimeIndicator();
            
            if (!inFocusMode) {
                toggleFocusMode();
            }
            
            runActivity(currentActivityIndex);
            showNotification("🚀 Timer started! Stay focused!");
        }

        function updateTotalTimeIndicator() {
            const totalTimeContainer = document.getElementById("totalTimeContainer");
            const endTimeContainer = document.getElementById("endTimeContainer");
            const progressContainer = document.querySelector('.progress-container');
            
            if (!totalTimeContainer || !endTimeContainer) return;

            const now = new Date();
            let totalSeconds = activities.reduce((sum, act, idx) => {
                if (idx < currentActivityIndex) return sum;
                return sum + (act.remainingTime || act.duration * 60);
            }, 0);

            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;

            totalTimeContainer.innerText = `⏰ Time Remaining: ${hours > 0 ? hours + 'h ' : ''}${minutes}m ${seconds}s`;

            const estimatedEnd = new Date(now.getTime() + totalSeconds * 1000);
            endTimeContainer.innerText = `🎯 Estimated End: ${estimatedEnd.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;

            const progressBar = document.getElementById("overallProgressBar");
            const totalPlanned = activities.reduce((sum, act) => sum + act.duration * 60, 0);
            const completedSeconds = totalPlanned - totalSeconds;
            const percentage = Math.min(100, Math.floor((completedSeconds / totalPlanned) * 100));
            progressBar.style.width = percentage + "%";

            totalTimeContainer.style.display = isRunning ? 'block' : 'none';
            endTimeContainer.style.display = isRunning ? 'block' : 'none';
            progressContainer.style.display = isRunning ? 'block' : 'none';
        }
        
        function skipToNext() {
            if (!isRunning) return;
            
            clearInterval(timerInterval);
            playSound("beepSound");
            
            const currentActivity = activities[currentActivityIndex];
            currentActivity.completed = true;
            updateActivityStatus(currentActivityIndex);
            
            const now = new Date();
            currentActivityIndex++;
            
            if (currentActivityIndex < activities.length) {
                const nextActivity = activities[currentActivityIndex];
                nextActivity.startTime = new Date(now);
                
                for (let i = currentActivityIndex + 1; i < activities.length; i++) {
                    const prevActivityEndTime = i === currentActivityIndex + 1 
                        ? new Date(nextActivity.startTime.getTime() + (nextActivity.duration * 60000))
                        : new Date(activities[i-1].startTime.getTime() + (activities[i-1].duration * 60000));
                    
                    activities[i].startTime = prevActivityEndTime;
                }
                
                updateActivityKey();
                updateClockDisplay();
                updateNextActivityIndicator();
                updateStats();
                
                runActivity(currentActivityIndex);
                showNotification(`⏭️ Skipped to: ${nextActivity.name}`);
            } else {
                endSession();
            }
        }

        function runActivity(index) {
            if (index >= activities.length) {
                endSession();
                return;
            }
            
            currentActivityIndex = index;
            let activity = activities[index];
            
            let remaining = paused ? pausedRemaining : activity.remainingTime;
            paused = false;

            document.getElementById("activityLabel").innerText = `Current: ${activity.name}`;
            document.getElementById("activityLabel").style.background = `linear-gradient(45deg, ${activity.color}, ${adjustBrightness(activity.color, 20)})`;

            updateTimerDisplay(remaining);
            updateNextActivityIndicator();
            updateTotalTimeIndicator();
            
            clearInterval(timerInterval);
            const startTime = Date.now();
            
            timerInterval = setInterval(() => {
                activity.elapsedTime += 1;
                remaining = activity.remainingTime - 1;
                activity.remainingTime = remaining;
                
                if (remaining <= 0) {
                    clearInterval(timerInterval);
                    playSound();
                    activities[index].completed = true;
                    updateActivityStatus(index);
                    updateClockDisplay();
                    updateStats();
                    document.getElementById("digitalTimer").innerText = "";
                    
                    showNotification(`✅ "${activity.name}" completed!`);
                    
                    if (index + 1 < activities.length) {
                        const now = new Date();
                        activities[index + 1].startTime = now;
                        
                        for (let i = index + 2; i < activities.length; i++) {
                            const prevEnd = new Date(activities[i-1].startTime.getTime() + 
                                                    (activities[i-1].duration * 60000));
                            activities[i].startTime = prevEnd;
                        }
                        
                        updateActivityKey();
                    }
                    
                    setTimeout(() => runActivity(index + 1), 1000);
                    return;
                }
                
                updateTimerDisplay(remaining);
                updateTotalTimeIndicator();
                let progress = (activity.duration * 60 - remaining) / (activity.duration * 60);
                updateClockDisplay(progress);
            }, 1000);
        }

        function endSession() {
            isRunning = false;
            document.body.classList.remove('timer-running');
            document.getElementById("activityLabel").innerText = "🎉 All Activities Completed!";
            document.getElementById("activityLabel").style.background = "linear-gradient(45deg, #4caf50, #66bb6a)";
            document.getElementById("digitalTimer").innerText = "";
            document.getElementById("pauseBtn").style.display = "none";
            document.getElementById("skipBtn").style.display = "none";
            document.getElementById("startBtn").style.display = "inline-block";
            
            document.getElementById("nextActivityContainer").style.display = "none";
            document.getElementById("totalTimeContainer").style.display = "none";
            document.getElementById("endTimeContainer").style.display = "none";
            document.querySelector('.progress-container').style.display = "none";
            
            updateStats();
            playSound();
            showNotification("🎉 Congratulations! All activities completed!");
            
            setTimeout(() => {
                showSummary();
            }, 2000);
        }
        
        function updateTimerDisplay(seconds) {
            let minutes = Math.floor(seconds / 60).toString().padStart(2, '0');
            let remainingSeconds = (seconds % 60).toString().padStart(2, '0');
            document.getElementById("digitalTimer").innerText = `${minutes}:${remainingSeconds}`;
        }
        
        function updateActivityStatus(index) {
            const statusElement = document.getElementById(`activity-status-${index}`);
            if (statusElement) {
                statusElement.innerText = "✔ Completed";
                statusElement.style.color = "#4caf50";
                statusElement.style.fontWeight = "bold";
            }
        }

        function pauseTimer() {
            if (!isRunning) return;
            
            clearInterval(timerInterval);
            paused = true;
            isRunning = false;
            
            pausedRemaining = activities[currentActivityIndex].remainingTime;
            
            document.getElementById("resumeBtn").style.display = "inline-block";
            document.getElementById("pauseBtn").style.display = "none";
            
            showNotification("⏸️ Timer paused");
        }

        function resumeTimer() {
            if (!paused) return;
            
            const now = new Date();
            const currentActivity = activities[currentActivityIndex];
            
            for (let i = currentActivityIndex; i < activities.length; i++) {
                if (i === currentActivityIndex) {
                    const timeElapsed = currentActivity.duration * 60 - pausedRemaining;
                    currentActivity.startTime = new Date(now.getTime() - (timeElapsed * 1000));
                } else {
                    const prevActivity = activities[i-1];
                    const prevEndTime = new Date(prevActivity.startTime.getTime() + 
                                              (prevActivity.remainingTime * 1000));
                    activities[i].startTime = prevEndTime;
                }
            }
            
            isRunning = true;
            document.getElementById("resumeBtn").style.display = "none";
            document.getElementById("pauseBtn").style.display = "inline-block";
            updateActivityKey();
            runActivity(currentActivityIndex);
            
            showNotification("▶️ Timer resumed");
        }

        function resetTimer() {
            clearInterval(timerInterval);
            isRunning = false;
            document.body.classList.remove('timer-running');
            paused = false;
            startingAngleOffset = 0;
            totalElapsedTime = 0;
            
            if (confirm("Reset all activities? This will clear your activity list.")) {
                activities = [];
                currentActivityIndex = 0;
                document.getElementById("activityLabel").innerText = "No Activities Started";
                document.getElementById("activityLabel").style.background = "linear-gradient(45deg, #ffd700, #ffed4e)";
                document.getElementById("digitalTimer").innerText = "";
                document.getElementById("resumeBtn").style.display = "none";
                document.getElementById("pauseBtn").style.display = "inline-block";
                document.getElementById("skipBtn").style.display = "none";
                document.getElementById("startBtn").style.display = "inline-block";
                updateClockDisplay();
                updateActivityKey();
                updateStats();
                
                document.getElementById("nextActivityContainer").style.display = "none";
                document.getElementById("totalTimeContainer").style.display = "none";
                document.getElementById("endTimeContainer").style.display = "none";
                document.querySelector('.progress-container').style.display = "none";
                
                showNotification("🔄 Activities cleared");
            } else {
                activities.forEach(act => {
                    act.completed = false;
                    act.startTime = null;
                    act.elapsedTime = 0;
                    act.remainingTime = act.duration * 60;
                });
                currentActivityIndex = 0;
                document.getElementById("activityLabel").innerText = "Timer Reset";
                document.getElementById("activityLabel").style.background = "linear-gradient(45deg, #ffd700, #ffed4e)";
                document.getElementById("digitalTimer").innerText = "";
                document.getElementById("resumeBtn").style.display = "none";
                document.getElementById("pauseBtn").style.display = "inline-block";
                document.getElementById("skipBtn").style.display = "none";
                document.getElementById("startBtn").style.display = "inline-block";
                updateActivityKey();
                updateClockDisplay();
                updateStats();
                
                document.getElementById("nextActivityContainer").style.display = "none";
                document.getElementById("totalTimeContainer").style.display = "none";
                document.getElementById("endTimeContainer").style.display = "none";
                document.querySelector('.progress-container').style.display = "none";
                
                showNotification("🔄 Timer reset");
            }
            
            if (inFocusMode) {
                toggleFocusMode();
            }
        }

        function saveActivities() {
            try {
                localStorage.setItem("activities", JSON.stringify(activities));
                // Silent save - no notification popup
            } catch (error) {
                console.error("Error saving activities:", error);
                // Only show error notifications
                showNotification("❌ Could not save activities");
            }
        }

        function loadActivities() {
            try {
                const saved = localStorage.getItem("activities");
                if (saved) {
                    activities = JSON.parse(saved);
                    activities.forEach(act => {
                        if (act.startTime) {
                            act.startTime = new Date(act.startTime);
                        }
                        act.completed = false;
                        if (typeof act.remainingTime === 'undefined') {
                            act.remainingTime = act.duration * 60;
                        }
                        if (typeof act.elapsedTime === 'undefined') {
                            act.elapsedTime = 0;
                        }
                    });
                    updateActivityKey();
                    updateClockDisplay();
                    updateStats();
                    showNotification("📂 Activities loaded!");
                } else {
                    showNotification("❌ No saved activities found");
                }
            } catch (error) {
                console.error("Error loading activities:", error);
                showNotification("❌ Could not load activities");
            }
        }

        // Utility Functions
        function adjustBrightness(color, percent) {
            const num = parseInt(color.replace("#",""), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 +
                (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255))
                .toString(16).slice(1);
        }

        function showNotification(message) {
            const notification = document.getElementById("notification");
            notification.textContent = message;
            notification.classList.add("show");
            
            setTimeout(() => {
                notification.classList.remove("show");
            }, 3000);
        }

        // Drag and Drop functionality
        function setupDragAndDrop() {
            const table = document.getElementById("activitiesTable");
            if (!table) return;
            
            const rows = table.querySelectorAll('.draggable-row');
            
            rows.forEach(row => {
                const dragHandle = row.querySelector('.drag-handle');
                
                dragHandle.addEventListener('mousedown', function(e) {
                    e.preventDefault();
                    dragStartIndex = parseInt(row.getAttribute('data-index'));
                    row.classList.add('dragging');
                    document.addEventListener('mousemove', handleDrag);
                    document.addEventListener('mouseup', stopDrag);
                });
                
                dragHandle.addEventListener('touchstart', function(e) {
                    dragStartIndex = parseInt(row.getAttribute('data-index'));
                    row.classList.add('dragging');
                    document.addEventListener('touchmove', handleTouchDrag);
                    document.addEventListener('touchend', stopDrag);
                });
            });
        }

        function handleDrag(e) {
            const draggingRow = document.querySelector('.dragging');
            if (!draggingRow) return;
            
            const table = document.getElementById("activitiesTable");
            const rows = Array.from(table.querySelectorAll('.draggable-row'));
            
            let closest = null;
            let closestDistance = Infinity;
            
            rows.forEach(row => {
                if (row === draggingRow) return;
                
                const rect = row.getBoundingClientRect();
                const rowMiddle = rect.top + rect.height / 2;
                const distance = Math.abs(e.clientY - rowMiddle);
                
                if (distance < closestDistance) {
                    closest = row;
                    closestDistance = distance;
                }
            });
            
            if (closest) {
                const rect = closest.getBoundingClientRect();
                const rowMiddle = rect.top + rect.height / 2;
                
                if (e.clientY < rowMiddle) {
                    table.insertBefore(draggingRow, closest);
                } else {
                    table.insertBefore(draggingRow, closest.nextSibling);
                }
                
                updateRowIndices();
            }
        }
        
        function handleTouchDrag(e) {
            const touch = e.touches[0];
            const mouseEvent = {
                clientX: touch.clientX,
                clientY: touch.clientY
            };
            handleDrag(mouseEvent);
        }
        
        function stopDrag() {
            const draggingRow = document.querySelector('.dragging');
            if (!draggingRow) return;
            
            draggingRow.classList.remove('dragging');
            const dragEndIndex = parseInt(draggingRow.getAttribute('data-index'));
            
            if (dragStartIndex !== dragEndIndex) {
                const [movedActivity] = activities.splice(dragStartIndex, 1);
                activities.splice(dragEndIndex, 0, movedActivity);
                
                updateActivityKey();
                updateClockDisplay();
                
                if (isRunning) {
                    if (currentActivityIndex === dragStartIndex) {
                        currentActivityIndex = dragEndIndex;
                    } else if (dragStartIndex < currentActivityIndex && currentActivityIndex <= dragEndIndex) {
                        currentActivityIndex--;
                    } else if (dragStartIndex > currentActivityIndex && currentActivityIndex >= dragEndIndex) {
                        currentActivityIndex++;
                    }
                }
                
                updateNextActivityIndicator();
                showNotification("📋 Activities reordered");
            }
            
            document.removeEventListener('mousemove', handleDrag);
            document.removeEventListener('mouseup', stopDrag);
            document.removeEventListener('touchmove', handleTouchDrag);
            document.removeEventListener('touchend', stopDrag);
        }
        
        function updateRowIndices() {
            const table = document.getElementById("activitiesTable");
            const rows = Array.from(table.querySelectorAll('.draggable-row'));
            
            rows.forEach((row, index) => {
                row.setAttribute('data-index', index);
            });
        }
        
        // Color Management Functions
        function openColorModal() {
            document.getElementById('colorModal').style.display = 'block';
        }
        
        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }
        
        function generateColorPalette() {
            const baseColor = document.getElementById('baseColor').value;
            const harmonyType = document.getElementById('harmonyType').value;
            
            const palette = generateHarmony(baseColor, harmonyType);
            colorPalette = palette;
            
            localStorage.setItem('colorPalette', JSON.stringify(colorPalette));
            displayColorPalette(palette);
            
            if (activities.length > 0) {
                activities.forEach((activity, index) => {
                    activity.color = palette[index % palette.length];
                });
                updateActivityKey();
                updateClockDisplay();
            }
        }
        
        function displayColorPalette(palette) {
            const container = document.getElementById('colorPalette');
            container.innerHTML = '';
            
            palette.forEach((color, index) => {
                const colorDiv = document.createElement('div');
                colorDiv.className = 'color-option';
                colorDiv.style.backgroundColor = color;
                colorDiv.title = color;
                colorDiv.setAttribute('data-color', color);
                
                colorDiv.addEventListener('click', () => {
                    selectColor(colorDiv);
                });
                
                container.appendChild(colorDiv);
            });
        }
        
        function selectColor(element) {
            document.querySelectorAll('.color-option').forEach(el => {
                el.classList.remove('selected');
            });
            element.classList.add('selected');
        }
        
        function openColorPickerForActivity(activityIndex) {
            window.currentEditingActivity = activityIndex;
            openColorModal();
            
            document.querySelectorAll('.color-option').forEach(option => {
                option.addEventListener('click', function() {
                    const color = this.getAttribute('data-color');
                    updateActivityColor(window.currentEditingActivity, color);
                    closeModal('colorModal');
                }, { once: true });
            });
        }
        
        function updateActivityColor(index, color) {
            if (index >= 0 && index < activities.length) {
                activities[index].color = color;
                updateActivityKey();
                updateClockDisplay();
                showNotification("🎨 Activity color updated!");
            }
        }
        
        // Color Harmony Generation
        function hexToRgb(hex) {
            hex = hex.replace('#', '');
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            return { r, g, b };
        }
        
        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            
            return { h: Math.round(h * 360), s: Math.round(s * 100), l: Math.round(l * 100) };
        }
        
        function hslToRgb(h, s, l) {
            h /= 360; s /= 100; l /= 100;
            let r, g, b;
            
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
        }
        
        function rgbToHex(r, g, b) {
            return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }
        
        function hexToHsl(hex) {
            const rgb = hexToRgb(hex);
            return rgbToHsl(rgb.r, rgb.g, rgb.b);
        }
        
        function hslToHex(h, s, l) {
            const rgb = hslToRgb(h, s, l);
            return rgbToHex(rgb.r, rgb.g, rgb.b);
        }
        
        function generateHarmony(baseColor, harmonyType) {
            const hsl = hexToHsl(baseColor);
            const { h, s, l } = hsl;
            let colors = [];
            
            switch (harmonyType) {
                case 'monochromatic':
                    colors = [
                        hslToHex(h, s, l),
                        hslToHex(h, s * 0.7, l),
                        hslToHex(h, s, l * 0.8),
                        hslToHex(h, s * 0.7, Math.min(100, l * 1.2)),
                        hslToHex(h, Math.min(100, s * 1.3), l * 0.8),
                        hslToHex(h, Math.min(100, s * 1.3), Math.min(100, l * 1.2))
                    ];
                    break;
                case 'analogous':
                    colors = [
                        hslToHex(h, s, l),
                        hslToHex((h + 30) % 360, s, l),
                        hslToHex((h + 60) % 360, s, l),
                        hslToHex((h - 30 + 360) % 360, s, l),
                        hslToHex((h - 60 + 360) % 360, s, l),
                        hslToHex(h, s * 0.8, Math.min(100, l * 1.2))
                    ];
                    break;
                case 'triadic':
                    colors = [
                        hslToHex(h, s, l),
                        hslToHex((h + 120) % 360, s, l),
                        hslToHex((h + 240) % 360, s, l),
                        hslToHex(h, s * 0.8, Math.min(100, l * 1.2)),
                        hslToHex((h + 120) % 360, s * 0.8, Math.min(100, l * 1.2)),
                        hslToHex((h + 240) % 360, s * 0.8, Math.min(100, l * 1.2))
                    ];
                    break;
                case 'tetradic':
                    colors = [
                        hslToHex(h, s, l),
                        hslToHex((h + 90) % 360, s, l),
                        hslToHex((h + 180) % 360, s, l),
                        hslToHex((h + 270) % 360, s, l),
                        hslToHex(h, s * 0.8, Math.min(100, l * 1.2)),
                        hslToHex((h + 180) % 360, s * 0.8, Math.min(100, l * 1.2))
                    ];
                    break;
                default:
                    colors = [...DEFAULT_COLORS];
            }
            
            return colors;
        }
        
        // Sound Management Functions
        function populateSoundOptions() {
            const soundList = document.getElementById('soundList');
            const sounds = [
                { id: 'chimeSound', name: '🔔 Digital Chime', desc: 'Gentle electronic tone' },
                { id: 'bellSound', name: '🔔 Bell', desc: 'Classic bell ring' },
                { id: 'beepSound', name: '📯 Beep', desc: 'Short alert beep' },
                { id: 'alarmSound', name: '⏰ Alarm Clock', desc: 'Traditional alarm sound' },
                { id: 'notificationSound', name: '📢 Notification', desc: 'Soft notification chord' }
            ];
            
            soundList.innerHTML = '';
            
            sounds.forEach(sound => {
                const option = document.createElement('div');
                option.className = `sound-option ${sound.id === selectedSound ? 'selected' : ''}`;
                option.setAttribute('data-sound-id', sound.id);
                option.innerHTML = `
                    <div>
                        <div style="font-weight: 600;">${sound.name}</div>
                        <div style="font-size: 0.9rem; color: #666; margin-top: 5px;">${sound.desc}</div>
                    </div>
                    <button onclick="previewSound('${sound.id}')" class="btn-secondary" style="margin-left: auto; padding: 8px 15px;">Preview</button>
                `;
                
                option.addEventListener('click', function(e) {
                    if (e.target.tagName !== 'BUTTON') {
                        selectSound(sound.id);
                    }
                });
                
                soundList.appendChild(option);
            });
        }
        
        function openSoundModal() {
            document.getElementById('soundModal').style.display = 'block';
        }
        
        function previewSound(soundId) {
            playSound(soundId);
        }
        
        function selectSound(soundId) {
            selectedSound = soundId;
            localStorage.setItem('selectedSound', soundId);
            
            document.querySelectorAll('.sound-option').forEach(option => {
                option.classList.toggle('selected', option.getAttribute('data-sound-id') === soundId);
            });
            
            showNotification("🔊 Sound updated!");
        }
        
        // Preset Management Functions
        function openPresetsModal() {
            document.getElementById('presetsModal').style.display = 'block';
            loadPresets();
        }
        
        function saveAsPreset() {
            if (activities.length === 0) {
                showNotification("❌ Please add at least one activity before saving a preset");
                return;
            }
            
            const presetName = document.getElementById('newPresetName').value.trim();
            if (!presetName) {
                showNotification("❌ Please enter a name for your preset");
                return;
            }
            
            try {
                let presets = {};
                if (localStorage.getItem('timerPresets')) {
                    presets = JSON.parse(localStorage.getItem('timerPresets'));
                }
                
                const presetActivities = activities.map(act => ({
                    name: act.name,
                    duration: act.duration,
                    color: act.color
                }));
                
                presets[presetName] = presetActivities;
                localStorage.setItem('timerPresets', JSON.stringify(presets));
                document.getElementById('newPresetName').value = '';
                loadPresets();
                
                showNotification(`✅ Preset "${presetName}" saved successfully!`);
            } catch (error) {
                console.error("Error saving preset:", error);
                showNotification("❌ Could not save preset");
            }
        }
        
        function loadPresets() {
            const container = document.getElementById('presetContainer');
            const noPresetsMsg = document.getElementById('noPresetsMessage');
            
            try {
                const presets = JSON.parse(localStorage.getItem('timerPresets') || '{}');
                const presetNames = Object.keys(presets);
                
                if (presetNames.length === 0) {
                    noPresetsMsg.style.display = 'block';
                    container.innerHTML = '';
                    container.appendChild(noPresetsMsg);
                    return;
                }
                
                noPresetsMsg.style.display = 'none';
                container.innerHTML = '';
                
                presetNames.forEach(name => {
                    const presetBox = document.createElement('div');
                    presetBox.style.cssText = `
                        border: 2px solid #e1e5e9;
                        border-radius: 15px;
                        padding: 20px;
                        width: 200px;
                        text-align: center;
                        cursor: pointer;
                        position: relative;
                        background: linear-gradient(135deg, #f8f9ff 0%, #e8f4fd 100%);
                        transition: all 0.3s ease;
                        margin: 10px;
                    `;
                    
                    const activitiesCount = presets[name].length;
                    const totalDuration = presets[name].reduce((sum, act) => sum + act.duration, 0);
                    
                    presetBox.innerHTML = `
                        <h4 style="margin-bottom: 10px; color: #333;">${name}</h4>
                        <p style="color: #666; margin: 5px 0;">${activitiesCount} activities</p>
                        <p style="color: #666; margin: 5px 0;">Total: ${totalDuration} min</p>
                        <button onclick="deletePreset('${name}', event)" style="
                            position: absolute;
                            top: 8px;
                            right: 8px;
                            background: transparent;
                            border: none;
                            cursor: pointer;
                            font-weight: bold;
                            color: #999;
                            font-size: 18px;
                            width: 25px;
                            height: 25px;
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            transition: all 0.3s ease;
                        " onmouseover="this.style.color='#ff4757'; this.style.backgroundColor='rgba(255,71,87,0.1)'" onmouseout="this.style.color='#999'; this.style.backgroundColor='transparent'">×</button>
                    `;
                    
                    presetBox.addEventListener('mouseover', () => {
                        presetBox.style.transform = 'translateY(-5px)';
                        presetBox.style.boxShadow = '0 15px 35px rgba(102, 126, 234, 0.2)';
                        presetBox.style.borderColor = '#4facfe';
                    });
                    
                    presetBox.addEventListener('mouseout', () => {
                        presetBox.style.transform = 'translateY(0)';
                        presetBox.style.boxShadow = 'none';
                        presetBox.style.borderColor = '#e1e5e9';
                    });
                    
                    presetBox.addEventListener('click', function(e) {
                        if (e.target.tagName !== 'BUTTON') {
                            loadPreset(name);
                        }
                    });
                    
                    container.appendChild(presetBox);
                });
            } catch (error) {
                console.error("Error loading presets:", error);
                noPresetsMsg.style.display = 'block';
                container.innerHTML = '';
                container.appendChild(noPresetsMsg);
            }
        }
        
        function loadPreset(presetName) {
            try {
                const presets = JSON.parse(localStorage.getItem('timerPresets') || '{}');
                
                if (!presets[presetName]) {
                    showNotification(`❌ Preset "${presetName}" not found`);
                    return;
                }
                
                if (activities.length > 0) {
                    if (!confirm(`Load preset "${presetName}"? This will replace your current activities.`)) {
                        return;
                    }
                }
                
                resetTimer();
                
                activities = presets[presetName].map(act => ({
                    ...act,
                    completed: false,
                    startTime: null,
                    elapsedTime: 0,
                    remainingTime: act.duration * 60
                }));
                
                updateActivityKey();
                updateClockDisplay();
                updateStats();
                closeModal('presetsModal');
                
                showNotification(`✅ Preset "${presetName}" loaded successfully!`);
            } catch (error) {
                console.error("Error loading preset:", error);
                showNotification("❌ Could not load preset");
            }
        }
        
        function deletePreset(presetName, event) {
            event.stopPropagation();
            
            if (!confirm(`Delete preset "${presetName}"?`)) {
                return;
            }
            
            try {
                const presets = JSON.parse(localStorage.getItem('timerPresets') || '{}');
                
                if (presets[presetName]) {
                    delete presets[presetName];
                    localStorage.setItem('timerPresets', JSON.stringify(presets));
                }
                
                loadPresets();
                showNotification(`🗑️ Preset "${presetName}" deleted`);
            } catch (error) {
                console.error("Error deleting preset:", error);
                showNotification("❌ Could not delete preset");
            }
        }

        // Import/Export Functions
        function exportActivities() {
            if (activities.length === 0) {
                showNotification("❌ No activities to export");
                return;
            }
            
            try {
                const exportData = activities.map(act => ({
                    name: act.name,
                    duration: act.duration,
                    color: act.color
                }));
                
                const jsonData = JSON.stringify(exportData, null, 2);
                const dataUri = "data:text/json;charset=utf-8," + encodeURIComponent(jsonData);
                
                const link = document.createElement('a');
                link.href = dataUri;
                link.download = `timer-activities-${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                showNotification("📤 Activities exported successfully!");
            } catch (error) {
                console.error("Error exporting activities:", error);
                showNotification("❌ Could not export activities");
            }
        }
        
        function importActivities() {
            try {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                
                input.onchange = e => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        try {
                            const importedData = JSON.parse(event.target.result);
                            
                            if (!Array.isArray(importedData)) {
                                throw new Error("Invalid import format: not an array");
                            }
                            
                            if (activities.length > 0) {
                                if (!confirm("This will replace your current activities. Continue?")) {
                                    return;
                                }
                                resetTimer();
                            }
                            
                            activities = importedData.map(act => {
                                if (!act.name || typeof act.duration !== 'number') {
                                    throw new Error("Invalid activity format");
                                }
                                
                                return {
                                    name: act.name,
                                    duration: act.duration,
                                    color: act.color || colorPalette[0],
                                    completed: false,
                                    startTime: null,
                                    elapsedTime: 0,
                                    remainingTime: act.duration * 60
                                };
                            });
                            
                            updateActivityKey();
                            updateClockDisplay();
                            updateStats();
                            
                            showNotification("📥 Activities imported successfully!");
                        } catch (error) {
                            console.error("Error parsing import file:", error);
                            showNotification("❌ Error importing activities: " + error.message);
                        }
                    };
                    
                    reader.readAsText(file);
                };
                
                input.click();
            } catch (error) {
                console.error("Error setting up import:", error);
                showNotification("❌ Could not import activities");
            }
        }

        // Session Summary Functions
        function showSummary() {
            const summaryModal = document.getElementById("summaryModal");
            const summaryList = document.getElementById("summaryList");
            const exportBtn = document.getElementById("exportSummaryBtn");
            const saveChartBtn = document.getElementById("saveChartBtn");
            const printBtn = document.getElementById("printSummaryBtn");
            
            summaryList.innerHTML = "";

            activities.forEach((act, i) => {
                const li = document.createElement("li");
                li.style.cssText = `
                    display: flex;
                    align-items: center;
                    padding: 15px;
                    margin: 10px 0;
                    background: linear-gradient(135deg, #f8f9ff 0%, #e8f4fd 100%);
                    border-radius: 12px;
                    border-left: 4px solid ${act.color};
                `;
                
                const minutes = Math.floor((act.elapsedTime || 0) / 60);
                const seconds = (act.elapsedTime || 0) % 60;
                
                li.innerHTML = `
                    <div style="width: 20px; height: 20px; background: ${act.color}; border-radius: 50%; margin-right: 15px; border: 2px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.2);"></div>
                    <div style="flex: 1;">
                        <strong style="color: #333;">${act.name}</strong>
                        <div style="font-size: 0.9rem; color: #666; margin-top: 5px;">
                            Planned: ${act.duration} min | Actual: ${minutes}m ${seconds}s | 
                            <span style="color: ${act.completed ? '#4caf50' : '#ff4757'}; font-weight: 600;">
                                ${act.completed ? '✅ Completed' : '❌ Incomplete'}
                            </span>
                        </div>
                    </div>
                `;
                summaryList.appendChild(li);
            });

            exportBtn.onclick = exportSummary;
            saveChartBtn.onclick = saveChartAsImage;
            printBtn.onclick = printSummary;
            summaryModal.style.display = "block";

            // Create chart
            const ctx = document.getElementById("summaryChart").getContext("2d");
            const labels = activities.map(act => act.name);
            const plannedData = activities.map(act => act.duration);
            const actualData = activities.map(act => Math.round((act.elapsedTime || 0) / 60));
            
            if (window.summaryChart) window.summaryChart.destroy();
            window.summaryChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels,
                    datasets: [
                        {
                            label: 'Planned (min)',
                            data: plannedData,
                            backgroundColor: activities.map(act => act.color + '80'),
                            borderColor: activities.map(act => act.color),
                            borderWidth: 2
                        },
                        {
                            label: 'Actual (min)',
                            data: actualData,
                            backgroundColor: activities.map(act => act.completed ? '#4caf50' : '#ff4757'),
                            borderColor: activities.map(act => act.completed ? '#388e3c' : '#d32f2f'),
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { 
                            display: true,
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 20
                            }
                        },
                        title: { 
                            display: true, 
                            text: 'Session Performance Overview',
                            font: {
                                size: 16,
                                weight: 'bold'
                            },
                            padding: 20
                        }
                    },
                    scales: {
                        y: { 
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Minutes'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Activities'
                            }
                        }
                    }
                }
            });

            saveSessionToHistory();
        }

        function exportSummary() {
            const completedCount = activities.filter(act => act.completed).length;
            const totalCount = activities.length;
            const totalMinutes = activities.reduce((sum, act) => sum + act.duration, 0);
            const actualMinutes = activities.reduce((sum, act) => sum + Math.round((act.elapsedTime || 0) / 60), 0);

            const lines = [
                `🎯 TIMER SESSION SUMMARY`,
                `Generated: ${new Date().toLocaleString()}`,
                ``,
                `📊 OVERVIEW`,
                `Total Activities: ${totalCount}`,
                `Completed: ${completedCount} (${Math.round((completedCount/totalCount)*100)}%)`,
                `Total Time Planned: ${totalMinutes} minutes`,
                `Total Time Actual: ${actualMinutes} minutes`,
                
                ``,
                `📋 DETAILED BREAKDOWN`,
                `${'='.repeat(50)}`
            ];

            activities.forEach((act, index) => {
                const actualTime = act.elapsedTime || 0;
                const minutes = Math.floor(actualTime / 60);
                const seconds = actualTime % 60;
                
                lines.push(`${index + 1}. ${act.name}`);
                lines.push(`   Planned: ${act.duration} minutes`);
                lines.push(`   Actual: ${minutes}m ${seconds}s`);
                lines.push(`   Status: ${act.completed ? '✅ Completed' : '❌ Incomplete'}`);
                lines.push('');
            });

            const blob = new Blob([lines.join('\n')], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);

            const link = document.createElement('a');
            link.href = url;
            link.download = `Timer_Session_Summary_${new Date().toISOString().slice(0, 10)}.txt`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            showNotification("📤 Summary exported successfully!");
        }

        function saveChartAsImage() {
            const canvas = document.getElementById("summaryChart");
            const image = canvas.toDataURL("image/png");
            const link = document.createElement("a");
            link.href = image;
            link.download = `Timer_Performance_Chart_${new Date().toISOString().slice(0, 10)}.png`;
            link.click();
            
            showNotification("🖼️ Chart saved as image!");
        }

        function printSummary() {
            const printWindow = window.open('', '_blank');
            const chartImage = document.getElementById("summaryChart").toDataURL("image/png");
            const completedCount = activities.filter(act => act.completed).length;
            const totalCount = activities.length;

            let html = `
                <html>
                <head>
                    <title>Timer Session Summary</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 40px; }
                        .header { text-align: center; margin-bottom: 30px; }
                        .stats { background: #f5f5f5; padding: 20px; border-radius: 10px; margin: 20px 0; }
                        .activity { margin: 15px 0; padding: 15px; border-left: 4px solid #4facfe; background: #f9f9f9; }
                        .chart { text-align: center; margin: 30px 0; }
                        @media print { .no-print { display: none; } }
                    </style>
                </head>
                <body>
                    <div class="header">
                        <h1>🎯 Timer Session Summary</h1>
                        <p>Generated: ${new Date().toLocaleString()}</p>
                    </div>
                    
                    <div class="stats">
                        <h3>📊 Session Overview</h3>
                        <p><strong>Total Activities:</strong> ${totalCount}</p>
                        <p><strong>Completed:</strong> ${completedCount} (${Math.round((completedCount/totalCount)*100)}%)</p>
                        <p><strong>Success Rate:</strong> ${Math.round((completedCount/totalCount)*100)}%</p>
                    </div>

                    <h3>📋 Activity Details</h3>
            `;

            activities.forEach((act, index) => {
                const minutes = Math.floor((act.elapsedTime || 0) / 60);
                const seconds = (act.elapsedTime || 0) % 60;
                
                html += `
                    <div class="activity" style="border-left-color: ${act.color};">
                        <h4>${index + 1}. ${act.name}</h4>
                        <p><strong>Planned:</strong> ${act.duration} minutes</p>
                        <p><strong>Actual:</strong> ${minutes}m ${seconds}s</p>
                        <p><strong>Status:</strong> ${act.completed ? '✅ Completed' : '❌ Incomplete'}</p>
                    </div>
                `;
            });

            html += `
                    <div class="chart">
                        <h3>📈 Performance Chart</h3>
                        <img src="${chartImage}" style="max-width: 100%; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
                    </div>
                </body>
                </html>
            `;

            printWindow.document.write(html);
            printWindow.document.close();
            printWindow.focus();
            setTimeout(() => {
                printWindow.print();
                printWindow.close();
            }, 500);
            
            showNotification("🖨️ Summary sent to printer!");
        }

        function saveSessionToHistory() {
            const session = {
                timestamp: new Date().toISOString(),
                activities: activities.map(act => ({
                    name: act.name,
                    duration: act.duration,
                    completed: act.completed,
                    elapsedTime: act.elapsedTime || 0,
                    color: act.color
                }))
            };

            const history = JSON.parse(localStorage.getItem('sessionHistory') || '[]');
            history.push(session);
            
            // Keep only last 50 sessions
            if (history.length > 50) {
                history.splice(0, history.length - 50);
            }
            
            localStorage.setItem('sessionHistory', JSON.stringify(history));
        }

        // Close modals when clicking outside
        window.onclick = function(event) {
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => {
                if (event.target === modal) {
                    modal.style.display = "none";
                }
            });
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            switch(e.key) {
                case ' ':
                    e.preventDefault();
                    if (isRunning) {
                        pauseTimer();
                    } else if (paused) {
                        resumeTimer();
                    } else {
                        startTimer();
                    }
                    break;
                case 'r':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        resetTimer();
                    }
                    break;
                case 's':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        saveActivities();
                    }
                    break;
                case 'f':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        toggleFocusMode();
                    }
                    break;
                case 'Escape':
                    const openModal = document.querySelector('.modal[style*="block"]');
                    if (openModal) {
                        openModal.style.display = 'none';
                    }
                    break;
            }
        });

        // Initialize insights rotation
        function rotateInsights() {
            const insights = [
                "🎯 Perfect timing to start your focused work session!",
                "⚡ Your productivity peaks with timed activities.",
                "📈 Break tasks into 25-minute focused sessions.",
                "🧠 Use breaks between activities to recharge.",
                "🎵 Try background music to enhance focus.",
                "💪 Physical movement between tasks boosts energy.",
                "📝 Review completed tasks for motivation.",
                "🌟 Celebrate small wins to maintain momentum.",
                "⏰ Consistent timing builds productive habits.",
                "🔄 Regular breaks prevent mental fatigue.",
                "💾 Your activity lists are automatically saved every 30 seconds.",
                "📱 This app works offline and syncs when connected.",
                "🎨 Customize colors to match your workflow preferences."
            ];
            
            const insightsList = document.getElementById('insights-list');
            let currentInsightIndex = 0;
            
            setInterval(() => {
                if (insightsList && !isRunning) {
                    const insight = insights[currentInsightIndex];
                    insightsList.innerHTML = `
                        <div style="padding: 15px; background: linear-gradient(135deg, #f8f9ff 0%, #e8f4fd 100%); margin-bottom: 12px; border-radius: 12px; border-left: 4px solid #4facfe; font-size: 0.95rem; animation: fadeInUp 0.5s ease-out;">
                            ${insight}
                        </div>
                    `;
                    currentInsightIndex = (currentInsightIndex + 1) % insights.length;
                }
            }, 10000); // Rotate every 10 seconds
        }

        // Add fade-in animation to CSS
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeInUp {
                from {
                    opacity: 0;
                    transform: translateY(20px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }
        `;
        document.head.appendChild(style);

        // Start insights rotation after page load
        setTimeout(rotateInsights, 3000);

        // Auto-save activities every 30 seconds
        setInterval(() => {
            if (activities.length > 0) {
                saveActivities();
            }
        }, 30000);

        // Show welcome message
        setTimeout(() => {
            if (activities.length === 0) {
                showNotification("👋 Welcome! Add your first activity to get started!");
            }
        }, 1000);
    </script>
</body>
</html>
