<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Activity Countdown Timer</title>
<!-- PWA Meta Tags for mytimer.io -->
<meta name="theme-color" content="#4CAF50">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="apple-mobile-web-app-title" content="MyTimer.io">
<meta name="msapplication-TileColor" content="#4CAF50">
<meta name="msapplication-TileImage" content="icons/icon-144x144.png">

<!-- Manifest -->
<link rel="manifest" href="manifest.json">

<!-- Icons for different platforms -->
<link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192x192.png">
<link rel="icon" type="image/png" sizes="512x512" href="icons/icon-512x512.png">
<link rel="apple-touch-icon" sizes="180x180" href="icons/icon-192x192.png">
<link rel="apple-touch-icon" sizes="152x152" href="icons/icon-152x152.png">
<link rel="apple-touch-icon" sizes="144x144" href="icons/icon-144x144.png">
<link rel="apple-touch-icon" sizes="120x120" href="icons/icon-128x128.png">
<link rel="apple-touch-icon" sizes="72x72" href="icons/icon-72x72.png">
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background-color: white;
            color: black;
            transition: background-color 0.3s, color 0.3s;
            margin: 0;
            padding: 15px;
        }
        body.dark-mode {
            background-color: #121212;
            color: white;
        }
        body.dark-mode .activity-key th, 
        body.dark-mode .activity-key td {
            border-color: #aaa;
        }
        body.dark-mode #analogClock {
            border-color: #aaa;
            background-color: #333;
        }
        body.dark-mode .modal-content {
            background-color: #222;
            color: white;
        }
        body.dark-mode .preset-box {
            background-color: #333;
            border-color: #555;
        }
        /* Focus mode styles */
        body.focus-mode .non-essential {
            display: none !important;
        }
        body.focus-mode .clock-container {
            max-width: 400px;
            max-height: 400px;
        }
        body.focus-mode #analogClock {
            width: 100%;
            height: 100%;
        }
        body.focus-mode #activityLabel {
            font-size: 1.8em;
            padding: 10px 20px;
            margin: 20px auto;
        }
        body.focus-mode #digitalTimer {
            font-size: 3em;
        }
        body.focus-mode .controls {
            margin: 30px auto;
        }
        body.focus-mode .controls button {
            padding: 15px 25px;
            font-size: 1.2em;
        }
        body.focus-mode .focus-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            opacity: 0.7;
        }
        body.focus-mode .focus-toggle:hover {
            opacity: 1;
        }
        .focus-toggle {
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        body.dark-mode .focus-toggle {
            background-color: #333;
            border-color: #555;
        }
        .clock-container {
            width: 90vw;
            max-width: 300px;
            height: 90vw;
            max-height: 300px;
            position: relative;
            margin: 20px auto;
            transition: max-width 0.3s, max-height 0.3s;
        }
        #analogClock {
            width: 100%;
            height: 100%;
            border: 5px solid black;
            border-radius: 50%;
            background: white;
        }
        .activity-key {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .activity-key table {
            border-collapse: collapse;
            width: 90%;
            max-width: 500px;
            margin: auto;
        }
        .activity-key th, .activity-key td {
            border: 1px solid black;
            padding: 5px;
            text-align: left;
        }
        .color-box {
            width: 20px;
            height: 20px;
            display: inline-block;
            cursor: pointer;
            border-radius: 3px;
        }
        #activityLabel {
            font-weight: bold;
            background-color: yellow;
            padding: 5px;
            display: inline-block;
            border-radius: 5px;
            transition: font-size 0.3s, padding 0.3s, margin 0.3s;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;
            margin: 10px 0;
            transition: margin 0.3s;
        }
        .controls button {
            padding: 8px 12px;
            font-weight: bold;
            min-width: 80px;
            transition: padding 0.3s, font-size 0.3s;
        }
        .feature-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
        }
        .feature-container button {
            padding: 8px 12px;
            min-width: 120px;
        }
        .dark-toggle {
            margin: 10px;
        }
        #digitalTimer {
            font-size: 1.5em;
            font-weight: bold;
            transition: font-size 0.3s;
        }
        
        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.7);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 10% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 600px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close-button:hover {
            color: black;
        }
        
        /* Color Picker Styles */
        .color-palette {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;
            margin-top: 15px;
        }
        .harmony-option {
            margin: 10px 0;
        }
        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
        }
        .color-option.selected {
            border: 2px solid #000;
            transform: scale(1.1);
        }
        .harmony-selector {
            margin-bottom: 15px;
        }
        
        /* Sound Selector Styles */
        .sound-option {
            display: flex;
            align-items: center;
            padding: 5px;
            margin: 5px 0;
            border: 1px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
        }
        .sound-option:hover {
            background-color: #f0f0f0;
        }
        .sound-option.selected {
            background-color: #e0e0ff;
        }
        .sound-option button {
            margin-left: auto;
        }
        body.dark-mode .sound-option {
            border-color: #555;
        }
        body.dark-mode .sound-option:hover {
            background-color: #333;
        }
        body.dark-mode .sound-option.selected {
            background-color: #303060;
        }
        
        /* Preset Management Styles */
        .preset-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
        }
        .preset-box {
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            width: 150px;
            text-align: center;
            cursor: pointer;
            position: relative;
            background-color: #f9f9f9;
        }
        .preset-box:hover {
            background-color: #f0f0f0;
        }
        .preset-box .delete-preset {
            position: absolute;
            top: 2px;
            right: 2px;
            background-color: transparent;
            border: none;
            cursor: pointer;
            font-weight: bold;
            color: #999;
        }
        .preset-box .delete-preset:hover {
            color: #f00;
        }
        #newPresetName {
            padding: 8px;
            width: 70%;
            margin: 10px 0;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        
        /* Drag and Drop Styles */
        .draggable-row {
            cursor: move;
        }
        .draggable-row.dragging {
            opacity: 0.5;
            background-color: #f0f0f0;
        }
        .drag-handle {
            cursor: move;
            padding: 5px;
            user-select: none;
        }
        .drag-handle::before {
            content: "☰";
        }
        
        @media screen and (max-width: 600px) {
            #activityLabel {
                font-size: 1em;
            }
            .activity-key table {
                font-size: 0.9em;
            }
            #digitalTimer {
                font-size: 1.2em;
            }
            .controls {
                flex-direction: column;
                align-items: center;
            }
            .controls button {
                width: 80%;
                margin: 3px 0;
            }
            .modal-content {
                width: 95%;
                margin: 5% auto;
                padding: 15px;
            }
            body.focus-mode #activityLabel {
                font-size: 1.4em;
            }
            body.focus-mode #digitalTimer {
                font-size: 2.2em;
            }
        }

        /* Next Activity Indicator (for Focus Mode) */
        .next-activity {
            padding: 8px 15px;
            border-radius: 5px;
            margin: 15px auto;
            display: inline-block;
            font-weight: bold;
            transition: opacity 0.3s;
            opacity: 0;
        }
        body.focus-mode .next-activity {
            opacity: 1;
        }
    </style>
</head>
<body>
    <h2 class="non-essential">Multi-Activity Countdown Timer</h2>
    <div class="dark-toggle non-essential">
        <label for="darkModeToggle"><input type="checkbox" id="darkModeToggle"> Dark Mode</label>
        <label for="realTimeClockToggle" style="margin-left: 15px;"><input type="checkbox" id="realTimeClockToggle" checked> Show Real-Time Clock</label>
    </div>
    <div class="clock-container">
        <canvas id="analogClock"></canvas>
    </div>
    <p id="activityLabel">No Activities Started</p>
    <p id="digitalTimer" aria-live="polite"></p>
    <div id="nextActivityContainer" class="next-activity" style="display: none;">
        Next: <span id="nextActivityLabel"></span>
    </div>
    <div class="controls">
        <button onclick="addActivity()" class="non-essential" aria-label="Add Activity">Add Activity</button>
        <button onclick="startTimer()" id="startBtn" aria-label="Start Timer"><b>START</b></button>
        <button onclick="pauseTimer()" id="pauseBtn" aria-label="Pause Timer">Pause</button>
        <button onclick="resumeTimer()" id="resumeBtn" style="display:none;" aria-label="Resume Timer">Resume</button>
        <button onclick="resetTimer()" aria-label="Reset Timer">Reset</button>
        <button onclick="skipToNext()" id="skipBtn" style="display:none;" aria-label="Skip to Next">Skip</button>
    </div>
    
    <div class="feature-container non-essential">
        <button onclick="openPresetsModal()" aria-label="Manage Presets">Presets</button>
        <button onclick="openColorModal()" aria-label="Choose Colors">Color Themes</button>
        <button onclick="openSoundModal()" aria-label="Select Sounds">Sound Effects</button>
        <button onclick="exportActivities()" aria-label="Export Activities">Export</button>
        <button onclick="importActivities()" aria-label="Import Activities">Import</button>
    </div>
    
    <div class="focus-toggle" onclick="toggleFocusMode()" title="Toggle Focus Mode">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"></path>
            <circle cx="12" cy="12" r="3"></circle>
        </svg>
    </div>
    
    <div class="activity-key non-essential" id="activityKey" aria-label="Activity List"></div>

    <!-- Modals -->
    <div id="colorModal" class="modal non-essential">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('colorModal')">&times;</span>
            <h3>Color Theme Selection</h3>
            <div class="harmony-selector">
                <label for="harmonyType">Color Harmony: </label>
                <select id="harmonyType" onchange="generateColorPalette()">
                    <option value="monochromatic">Monochromatic</option>
                    <option value="analogous">Analogous</option>
                    <option value="complementary">Complementary</option>
                    <option value="splitComplementary">Split Complementary</option>
                    <option value="triadic">Triadic</option>
                    <option value="tetradic">Tetradic</option>
                </select>
            </div>
            <div class="harmony-option">
                <label for="baseColor">Base Color: </label>
                <input type="color" id="baseColor" value="#3366ff" onchange="generateColorPalette()">
            </div>
            <div class="color-palette" id="colorPalette"></div>
        </div>
    </div>

    <div id="soundModal" class="modal non-essential">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('soundModal')">&times;</span>
            <h3>Sound Selection</h3>
            <p>Choose a sound to play when an activity completes:</p>
            <div id="soundList"></div>
        </div>
    </div>

    <div id="presetsModal" class="modal non-essential">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('presetsModal')">&times;</span>
            <h3>Preset Management</h3>
            <p>Save your current activities as a preset or load a previously saved preset:</p>
            
            <div>
                <input type="text" id="newPresetName" placeholder="Preset Name (e.g. Morning Routine)">
                <button onclick="saveAsPreset()">Save Current as Preset</button>
            </div>
            
            <h4>Available Presets</h4>
            <div class="preset-container" id="presetContainer">
                <p id="noPresetsMessage">No saved presets found.</p>
            </div>
        </div>
    </div>

    <!-- Audio elements -->
    <audio id="chimeSound" src="https://actions.google.com/sounds/v1/alarms/digital_watch_alarm_long.ogg"></audio>
    <audio id="bellSound" src="https://actions.google.com/sounds/v1/alarms/medium_bell_ringing_near.ogg"></audio>
    <audio id="beepSound" src="https://actions.google.com/sounds/v1/alarms/beep_short.ogg"></audio>
    <audio id="alarmSound" src="https://actions.google.com/sounds/v1/alarms/alarm_clock.ogg"></audio>
    <audio id="notificationSound" src="https://actions.google.com/sounds/v1/alarms/notification_alert_chord.ogg"></audio>

    <script>
        // Constants
        const DEFAULT_COLORS = ["#3366ff", "#33cc33", "#ff6600", "#9933cc", "#cc3366", "#33cccc"];
        
        // Global variables
        let activities = [];
        let currentActivityIndex = 0;
        let timerInterval;
        let isRunning = false;
        let paused = false;
        let pausedRemaining = 0;
        let canvas, ctx, radius;
        let selectedSound = "chimeSound";
        let colorPalette = [...DEFAULT_COLORS];
        let dragStartIndex;
        let inFocusMode = false;
        let startingAngleOffset = 0; // Will store the offset angle based on current time
        let totalElapsedTime = 0; // Track total elapsed time

        document.addEventListener("DOMContentLoaded", () => {
            initializeCanvas();
            document.getElementById("darkModeToggle").addEventListener("change", toggleDarkMode);
            document.getElementById("realTimeClockToggle").addEventListener("change", function() {
                toggleRealTimeClock();
            });
            loadSavedSettings();
            populateSoundOptions();
            generateColorPalette();
            
            // Start the real-time clock
            startRealTimeClock();
            
            // Load from storage if available
            if (localStorage.getItem("activities")) {
                loadActivities();
            }
        });

        function loadSavedSettings() {
            // Load dark mode setting
            if (localStorage.getItem("darkMode") === "true") {
                document.getElementById("darkModeToggle").checked = true;
                document.body.classList.add("dark-mode");
            }
            
            // Load focus mode setting
            if (localStorage.getItem("focusMode") === "true") {
                inFocusMode = true;
                document.body.classList.add("focus-mode");
            }
            
            // Load real-time clock setting
            if (localStorage.getItem("showRealTimeClock") === "false") {
                showRealTimeClock = false;
                document.getElementById("realTimeClockToggle").checked = false;
            }
            
            // Load selected sound
            if (localStorage.getItem("selectedSound")) {
                selectedSound = localStorage.getItem("selectedSound");
            }
            
            // Load color palette
            if (localStorage.getItem("colorPalette")) {
                try {
                    colorPalette = JSON.parse(localStorage.getItem("colorPalette"));
                } catch (e) {
                    console.error("Error loading color palette:", e);
                    colorPalette = [...DEFAULT_COLORS];
                }
            }
        }

        function initializeCanvas() {
            canvas = document.getElementById("analogClock");
            resizeCanvas();
            ctx = canvas.getContext("2d");
            radius = canvas.width / 2;
            ctx.translate(radius, radius);
            window.addEventListener('resize', resizeCanvas);
            updateClockDisplay();
        }

        function resizeCanvas() {
            const container = document.querySelector('.clock-container');
            const size = Math.min(container.clientWidth, container.clientHeight);
            canvas.width = size;
            canvas.height = size;
        }

        function toggleDarkMode(e) {
            document.body.classList.toggle("dark-mode", e.target.checked);
            localStorage.setItem("darkMode", e.target.checked);
            updateClockDisplay(); // Redraw the clock with appropriate colors
        }
        
        function toggleFocusMode() {
            inFocusMode = !inFocusMode;
            document.body.classList.toggle("focus-mode", inFocusMode);
            localStorage.setItem("focusMode", inFocusMode);
            
            // If we're running and in focus mode, show the next activity indicator
            updateNextActivityIndicator();
            
            // Resize canvas to adjust to new container size
            setTimeout(() => {
                resizeCanvas();
                updateClockDisplay();
                
                // Force canvas to match container dimensions
                const container = document.querySelector('.clock-container');
                const canvas = document.getElementById('analogClock');
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                radius = canvas.width / 2;
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.translate(radius, radius);
            }, 300);
        }
        
        function updateNextActivityIndicator() {
            const nextActivityContainer = document.getElementById("nextActivityContainer");
            
            if (isRunning && inFocusMode && currentActivityIndex < activities.length - 1) {
                const nextActivity = activities[currentActivityIndex + 1];
                document.getElementById("nextActivityLabel").innerText = `${nextActivity.name} (${nextActivity.duration}m)`;
                document.getElementById("nextActivityLabel").style.backgroundColor = nextActivity.color;
                nextActivityContainer.style.display = "inline-block";
            } else {
                nextActivityContainer.style.display = "none";
            }
        }

        function drawClockBase() {
            ctx.beginPath();
            ctx.arc(0, 0, radius - 5, 0, 2 * Math.PI);
            ctx.fillStyle = document.body.classList.contains("dark-mode") ? "#333" : "white";
            ctx.fill();
            ctx.lineWidth = 5;
            ctx.strokeStyle = document.body.classList.contains("dark-mode") ? "#aaa" : "black";
            ctx.stroke();
        }

        function drawClockNumbers() {
            ctx.font = radius * 0.15 + "px Arial";
            ctx.fillStyle = document.body.classList.contains("dark-mode") ? "white" : "black";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            for (let i = 1; i <= 12; i++) {
                let angle = (i * 30) * (Math.PI / 180);
                let x = Math.cos(angle - Math.PI / 2) * (radius - 30);
                let y = Math.sin(angle - Math.PI / 2) * (radius - 30);
                ctx.fillText(i, x, y);
            }
        }

        function drawMinuteHashes() {
            ctx.strokeStyle = document.body.classList.contains("dark-mode") ? "white" : "black";
            for (let i = 0; i < 60; i++) {
                let angle = i * 6 * (Math.PI / 180);
                let x1 = Math.cos(angle - Math.PI / 2) * (radius - 10);
                let y1 = Math.sin(angle - Math.PI / 2) * (radius - 10);
                let x2 = Math.cos(angle - Math.PI / 2) * (radius - 5);
                let y2 = Math.sin(angle - Math.PI / 2) * (radius - 5);
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        }
        
        function drawRealTimeClock() {
            // Get current time
            const now = new Date();
            const hours = now.getHours() % 12;
            const minutes = now.getMinutes();
            const seconds = now.getSeconds();
            const milliseconds = now.getMilliseconds();
            
            // Get precise positions accounting for seconds and milliseconds
            // For the minute hand, we'll move it smoothly based on seconds and milliseconds
            const smoothMinutes = minutes + (seconds / 60) + (milliseconds / 60000);
            
            // For the hour hand, we'll move it smoothly based on minutes
            const smoothHours = hours + (smoothMinutes / 60);
            
            // Draw hour hand
            ctx.strokeStyle = document.body.classList.contains("dark-mode") ? "#fff" : "#000";
            ctx.lineWidth = 6;
            ctx.beginPath();
            const hourAngle = smoothHours * 30 * (Math.PI / 180);
            ctx.moveTo(0, 0);
            ctx.lineTo(
                Math.cos(hourAngle - Math.PI / 2) * (radius * 0.5),
                Math.sin(hourAngle - Math.PI / 2) * (radius * 0.5)
            );
            ctx.stroke();
            
            // Draw minute hand
            ctx.strokeStyle = document.body.classList.contains("dark-mode") ? "#fff" : "#000";
            ctx.lineWidth = 4;
            ctx.beginPath();
            const minuteAngle = smoothMinutes * 6 * (Math.PI / 180);
            ctx.moveTo(0, 0);
            ctx.lineTo(
                Math.cos(minuteAngle - Math.PI / 2) * (radius * 0.7),
                Math.sin(minuteAngle - Math.PI / 2) * (radius * 0.7)
            );
            ctx.stroke();
            
            // Draw second hand
            ctx.strokeStyle = "#ff0000";
            ctx.lineWidth = 2;
            ctx.beginPath();
            const secondAngle = seconds * 6 * (Math.PI / 180);
            ctx.moveTo(0, 0);
            ctx.lineTo(
                Math.cos(secondAngle - Math.PI / 2) * (radius * 0.8),
                Math.sin(secondAngle - Math.PI / 2) * (radius * 0.8)
            );
            ctx.stroke();
            
            // Draw center circle
            ctx.fillStyle = "#ff0000";
            ctx.beginPath();
            ctx.arc(0, 0, radius * 0.04, 0, 2 * Math.PI);
            ctx.fill();
            
            // Display digital time (24-hour or 12-hour based on preference)
            ctx.fillStyle = document.body.classList.contains("dark-mode") ? "#fff" : "#000";
            ctx.font = radius * 0.1 + "px Arial";
            ctx.textAlign = "center";
            
            // Show user's locale-formatted time
            const timeString = now.toLocaleTimeString([], { timeStyle: 'short' });
            ctx.fillText(timeString, 0, -radius * 0.2);
        }

        function drawActivitySectors(currentProgress = 0) {
            if (activities.length === 0) return;
            
            // Start angle is now offset by the current time position
            let startAngle = -Math.PI / 2 + (isRunning ? startingAngleOffset : 0);
            
            activities.forEach((activity, index) => {
                let arcLength = (activity.duration / 60) * 2 * Math.PI;
                let endAngle = startAngle + arcLength;

                ctx.beginPath();
                ctx.moveTo(0, 0);
                if (index === currentActivityIndex && isRunning) {
                    // For the current activity, we only draw from the current progress point to the end
                    // This makes the sector disappear clockwise (from start to end)
                    let progressStart = startAngle + arcLength * currentProgress;
                    ctx.arc(0, 0, radius - 15, progressStart, endAngle);
                    ctx.fillStyle = activity.color;
                } else {
                    ctx.arc(0, 0, radius - 15, startAngle, endAngle);
                    ctx.fillStyle = activity.color;
                    ctx.globalAlpha = activity.completed ? 0.5 : 0.2;
                }
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;
                startAngle = endAngle;
            });
        }

        function updateClockDisplay(currentProgress = 0) {
            // Reset transform to clear the entire canvas properly
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.translate(radius, radius);
            
            drawClockBase();
            drawClockNumbers();
            drawMinuteHashes();
            drawActivitySectors(currentProgress); // Now uses offset based on current time
            
            // Draw the real-time clock hands on top
            if (showRealTimeClock) {
                drawRealTimeClock();
            }
        }
        
        // Setup real-time clock updating
        let clockInterval;
        let showRealTimeClock = true; // Default to showing real-time clock
        
        function startRealTimeClock() {
            // Update immediately
            updateClockDisplay();
            
            // Then update more frequently (60fps) to ensure smooth hand movement
            clockInterval = setInterval(() => {
                // Only update if not currently running a timer to avoid visual conflicts
                if (!isRunning) {
                    updateClockDisplay();
                }
            }, 16); // ~60 frames per second for smooth animation
        }
        
        function stopRealTimeClock() {
            clearInterval(clockInterval);
        }
        
        function toggleRealTimeClock() {
            showRealTimeClock = !showRealTimeClock;
            localStorage.setItem("showRealTimeClock", showRealTimeClock);
            
            // Update clock display immediately to show/hide the clock
            updateClockDisplay();
            
            // Update checkbox state
            document.getElementById("realTimeClockToggle").checked = showRealTimeClock;
        }

        function playSound(soundId = selectedSound) {
            try {
                const soundElement = document.getElementById(soundId);
                if (soundElement) {
                    // Reset to beginning
                    soundElement.currentTime = 0;
                    
                    // Limit sound playback to 5 seconds
                    const originalDuration = soundElement.duration;
                    
                    // Play the sound
                    soundElement.play().catch(error => {
                        console.warn("Could not play sound:", error);
                    });
                    
                    // Set a timeout to stop the sound after 5 seconds
                    setTimeout(() => {
                        if (!soundElement.paused) {
                            soundElement.pause();
                            soundElement.currentTime = 0;
                        }
                    }, 5000); // 5 seconds
                }
            } catch (error) {
                console.error("Error playing sound:", error);
            }
        }

        function addActivity() {
            let name = prompt("Enter activity name:");
            if (!name || name.trim() === "") return;

            let durationInput = prompt("Enter duration (minutes):");
            let duration = parseInt(durationInput);
            
            if (isNaN(duration) || duration <= 0) {
                alert("Please enter a valid positive number for duration.");
                return;
            }

            // Use color from palette
            let color = colorPalette[activities.length % colorPalette.length];
            activities.push({ 
                name, 
                duration, 
                color, 
                completed: false,
                startTime: null, // Will be set when timer starts
                elapsedTime: 0,  // Track elapsed time for this activity
                remainingTime: duration * 60 // Store remaining time in seconds
            });
            
            updateClockDisplay();
            updateActivityKey();
        }

        function updateActivityKey() {
            let keyContainer = document.getElementById("activityKey");
            keyContainer.innerHTML = "<h3>Activity Key</h3><p><small>Drag rows to reorder activities</small></p>";
            
            if (activities.length === 0) {
                keyContainer.innerHTML += "<p>No activities added yet.</p>";
                return;
            }
            
            let table = document.createElement("table");
            table.id = "activitiesTable";
            let headerRow = table.insertRow();
            headerRow.innerHTML = "<th></th><th>Color</th><th>Activity</th><th>Time (min)</th><th>Start Time</th><th>Status</th><th>Actions</th>";
            
            activities.forEach((act, i) => {
                let row = table.insertRow();
                row.classList.add("draggable-row");
                row.setAttribute("data-index", i);
                const statusId = `activity-status-${i}`;
                
                // Create cells
                let dragCell = row.insertCell();
                let colorCell = row.insertCell();
                let nameCell = row.insertCell();
                let durationCell = row.insertCell();
                let startTimeCell = row.insertCell();
                let statusCell = row.insertCell();
                let actionsCell = row.insertCell();
                
                // Add drag handle
                dragCell.classList.add("drag-handle");
                
                // Set up editable cells and content
                colorCell.innerHTML = `<span class='color-box' style='background:${act.color}' onclick='openColorPickerForActivity(${i})'></span>`;
                nameCell.setAttribute('contenteditable', 'true');
                nameCell.innerText = act.name;
                nameCell.addEventListener('blur', () => validateAndUpdateActivity(i, 'name', nameCell.innerText));
                
                durationCell.setAttribute('contenteditable', 'true');
                durationCell.innerText = act.duration;
                durationCell.addEventListener('blur', () => validateAndUpdateActivity(i, 'duration', durationCell.innerText));
                
                // Start time (calculated or actual)
                startTimeCell.id = `activity-start-time-${i}`;
                startTimeCell.innerText = act.startTime ? formatTime(act.startTime) : calculateProjectedStartTime(i);
                
                statusCell.id = statusId;
                statusCell.innerText = act.completed ? "✔ Completed" : "Pending";
                
                // Delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.innerText = 'Delete';
                deleteBtn.onclick = () => deleteActivity(i);
                actionsCell.appendChild(deleteBtn);
            });
            
            keyContainer.appendChild(table);
            
            // Set up drag and drop
            setupDragAndDrop();
        }
        
        // Helper function to format time
        function formatTime(date) {
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }
        
        // Calculate projected start time based on current time and preceding activities
        function calculateProjectedStartTime(activityIndex) {
            if (isRunning) {
                // If timer is running, use the actual start times that were set
                if (activities[activityIndex].startTime) {
                    return formatTime(activities[activityIndex].startTime);
                } else {
                    return "Pending";
                }
            }
            
            // Start with current time
            const now = new Date();
            let projectedStart = new Date(now);
            
            // Add durations of previous activities
            for (let i = 0; i < activityIndex; i++) {
                projectedStart = new Date(projectedStart.getTime() + activities[i].duration * 60000);
            }
            
            return formatTime(projectedStart);
        }
        
        // Update all projected start times
        function updateProjectedStartTimes() {
            activities.forEach((activity, index) => {
                const startTimeCell = document.getElementById(`activity-start-time-${index}`);
                if (startTimeCell) {
                    startTimeCell.innerText = activity.startTime ? 
                        formatTime(activity.startTime) : 
                        calculateProjectedStartTime(index);
                }
            });
        }
        
        function validateAndUpdateActivity(index, field, value) {
            if (index >= activities.length) return;
            
            if (field === 'name') {
                if (value.trim() === '') {
                    alert('Activity name cannot be empty');
                    updateActivityKey(); // Revert to previous value
                    return;
                }
                activities[index].name = value.trim();
            } 
            else if (field === 'duration') {
                const duration = parseInt(value);
                if (isNaN(duration) || duration <= 0) {
                    alert('Duration must be a positive number');
                    updateActivityKey(); // Revert to previous value
                    return;
                }
                activities[index].duration = duration;
                // Update remaining time if not started yet
                if (!activities[index].startTime || activities[index].completed) {
                    activities[index].remainingTime = duration * 60;
                }
            }
            
            updateClockDisplay();
            updateNextActivityIndicator();
        }
        
        function deleteActivity(index) {
            if (isRunning) {
                alert("Please stop the timer before deleting activities.");
                return;
            }
            
            if (confirm(`Delete activity "${activities[index].name}"?`)) {
                activities.splice(index, 1);
                updateActivityKey();
                updateClockDisplay();
                
                if (currentActivityIndex >= index) {
                    currentActivityIndex = Math.max(0, currentActivityIndex - 1);
                }
            }
        }

        function startTimer() {
            if (isRunning) return;
            if (activities.length === 0) {
                alert("Please add at least one activity first.");
                return;
            }
            
            isRunning = true;
            document.getElementById("resumeBtn").style.display = "none";
            document.getElementById("pauseBtn").style.display = "inline-block";
            document.getElementById("skipBtn").style.display = "inline-block";
            document.getElementById("startBtn").style.display = "none";
            
            // Calculate the starting angle offset based on current time
            const now = new Date();
            const minutes = now.getMinutes();
            const seconds = now.getSeconds();
            
            // Convert current time to angle (360 degrees = 60 minutes)
            startingAngleOffset = ((minutes * 60 + seconds) / 3600) * (2 * Math.PI);
            
            // Reset total elapsed time
            totalElapsedTime = 0;
            
            // Set start times for all activities based on now
            let currentStartTime = new Date(now);
            activities.forEach((activity, index) => {
                activity.startTime = new Date(currentStartTime);
                activity.completed = index < currentActivityIndex;
                activity.elapsedTime = 0;
                activity.remainingTime = activity.duration * 60;
                
                // Add this activity's duration to get the next start time
                currentStartTime = new Date(currentStartTime.getTime() + activity.duration * 60000);
            });
            
            // Update the activity table to show start times
            updateActivityKey();
            
            // Auto-enable focus mode when starting
            if (!inFocusMode) {
                toggleFocusMode();
            }
            
            runActivity(currentActivityIndex);
        }
        
        function skipToNext() {
            if (!isRunning) return;
            
            clearInterval(timerInterval);
            playSound("beepSound"); // Play a different sound for skip
            
            // Mark current activity as completed
            const currentActivity = activities[currentActivityIndex];
            currentActivity.completed = true;
            updateActivityStatus(currentActivityIndex);
            
            // Get the current time
            const now = new Date();
            
            // Move to next activity
            currentActivityIndex++;
            
            if (currentActivityIndex < activities.length) {
                const nextActivity = activities[currentActivityIndex];
                
                // Set the start time of the next activity to now
                nextActivity.startTime = new Date(now);
                
                // Calculate time difference between planned and actual start
                const originalStartTime = nextActivity.startTime;
                
                // Update the start times of all subsequent activities based on the remaining durations
                for (let i = currentActivityIndex + 1; i < activities.length; i++) {
                    const prevActivityEndTime = i === currentActivityIndex + 1 
                        ? new Date(nextActivity.startTime.getTime() + (nextActivity.duration * 60000))
                        : new Date(activities[i-1].startTime.getTime() + (activities[i-1].duration * 60000));
                    
                    activities[i].startTime = prevActivityEndTime;
                }
                
                // Update the UI to reflect these changes
                updateActivityKey();
                updateClockDisplay();
                updateNextActivityIndicator();
                
                // Run the next activity
                runActivity(currentActivityIndex);
            } else {
                // All activities completed
                isRunning = false;
                document.getElementById("activityLabel").innerText = "All Activities Completed!";
                document.getElementById("activityLabel").style.backgroundColor = "lightgreen";
                document.getElementById("digitalTimer").innerText = "";
                document.getElementById("pauseBtn").style.display = "none";
                document.getElementById("skipBtn").style.display = "none";
                document.getElementById("startBtn").style.display = "inline-block";
                
                // Hide next activity indicator
                document.getElementById("nextActivityContainer").style.display = "none";
                
                playSound(); // Play completion sound
            }
        }

        function runActivity(index) {
            if (index >= activities.length) {
                isRunning = false;
                document.getElementById("activityLabel").innerText = "All Activities Completed!";
                document.getElementById("activityLabel").style.backgroundColor = "lightgreen";
                document.getElementById("digitalTimer").innerText = "";
                document.getElementById("pauseBtn").style.display = "none";
                document.getElementById("skipBtn").style.display = "none";
                document.getElementById("startBtn").style.display = "inline-block";
                
                // Hide next activity indicator
                document.getElementById("nextActivityContainer").style.display = "none";
                
                playSound(); // Play completion sound
                return;
            }
            
            currentActivityIndex = index;
            let activity = activities[index];
            
            // Use remaining time directly from the activity data
            let remaining;
            if (paused) {
                remaining = pausedRemaining;
            } else {
                // If not paused, use the remaining time property
                remaining = activity.remainingTime;
            }
            
            paused = false;

            document.getElementById("activityLabel").innerText = `Current: ${activity.name}`;
            document.getElementById("activityLabel").style.backgroundColor = activity.color;

            updateTimerDisplay(remaining);
            updateNextActivityIndicator();
            
            clearInterval(timerInterval);
            const startTime = Date.now(); // Record the start time for this session
            timerInterval = setInterval(() => {
                // Calculate elapsed time in this session
                const sessionElapsed = Math.floor((Date.now() - startTime) / 1000);
                
                // Update activity's elapsed time
                activity.elapsedTime += 1;
                
                // Directly decrement the remaining time
                remaining = activity.remainingTime - 1;
                activity.remainingTime = remaining;
                
                if (remaining <= 0) {
                    clearInterval(timerInterval);
                    playSound();
                    activities[index].completed = true;
                    updateActivityStatus(index);
                    updateClockDisplay();
                    document.getElementById("digitalTimer").innerText = "";
                    
                    // Set the next activity's start time based on now
                    if (index + 1 < activities.length) {
                        const now = new Date();
                        activities[index + 1].startTime = now;
                        
                        // Update all subsequent start times
                        for (let i = index + 2; i < activities.length; i++) {
                            const prevEnd = new Date(activities[i-1].startTime.getTime() + 
                                                    (activities[i-1].duration * 60000));
                            activities[i].startTime = prevEnd;
                        }
                        
                        // Update activity key to show new start times
                        updateActivityKey();
                    }
                    
                    runActivity(index + 1);
                    return;
                }
                
                updateTimerDisplay(remaining);
                let progress = (activity.duration * 60 - remaining) / (activity.duration * 60);
                updateClockDisplay(progress);
            }, 1000);
        }
        
        function updateTimerDisplay(seconds) {
            let minutes = Math.floor(seconds / 60).toString().padStart(2, '0');
            let remainingSeconds = (seconds % 60).toString().padStart(2, '0');
            document.getElementById("digitalTimer").innerText = `${minutes}:${remainingSeconds}`;
        }
        
        function updateActivityStatus(index) {
            const statusElement = document.getElementById(`activity-status-${index}`);
            if (statusElement) {
                statusElement.innerText = "✔ Completed";
            }
        }

        function pauseTimer() {
            if (!isRunning) return;
            
            clearInterval(timerInterval);
            paused = true;
            isRunning = false;
            
            // Store the current remaining time
            pausedRemaining = activities[currentActivityIndex].remainingTime;
            
            document.getElementById("resumeBtn").style.display = "inline-block";
            document.getElementById("pauseBtn").style.display = "none";
        }

        function resumeTimer() {
            if (!paused) return;
            
            const now = new Date();
            const currentActivity = activities[currentActivityIndex];
            
            // Calculate time spent paused
            const pauseTime = now;
            
            // Update start times for all activities from current onwards
            // to maintain the correct remaining time
            for (let i = currentActivityIndex; i < activities.length; i++) {
                // First activity resumes now
                if (i === currentActivityIndex) {
                    // Adjust start time to maintain the correct remaining time
                    const timeElapsed = currentActivity.duration * 60 - pausedRemaining;
                    currentActivity.startTime = new Date(now.getTime() - (timeElapsed * 1000));
                } else {
                    // Subsequent activities start when previous ends
                    const prevActivity = activities[i-1];
                    const prevEndTime = new Date(prevActivity.startTime.getTime() + 
                                              (prevActivity.remainingTime * 1000));
                    activities[i].startTime = prevEndTime;
                }
            }
            
            isRunning = true;
            document.getElementById("resumeBtn").style.display = "none";
            document.getElementById("pauseBtn").style.display = "inline-block";
            updateActivityKey();
            runActivity(currentActivityIndex);
        }

        function resetTimer() {
            clearInterval(timerInterval);
            isRunning = false;
            paused = false;
            startingAngleOffset = 0; // Reset the offset angle
            totalElapsedTime = 0;
            
            if (confirm("Reset all activities? This will clear your activity list.")) {
                activities = [];
                currentActivityIndex = 0;
                document.getElementById("activityLabel").innerText = "No Activities Started";
                document.getElementById("activityLabel").style.backgroundColor = "yellow";
                document.getElementById("digitalTimer").innerText = "";
                document.getElementById("resumeBtn").style.display = "none";
                document.getElementById("pauseBtn").style.display = "inline-block";
                document.getElementById("skipBtn").style.display = "none";
                document.getElementById("startBtn").style.display = "inline-block";
                updateClockDisplay();
                updateActivityKey();
                
                // Hide next activity indicator
                document.getElementById("nextActivityContainer").style.display = "none";
            } else {
                // Just reset the current session without clearing activities
                activities.forEach(act => {
                    act.completed = false;
                    act.startTime = null;
                    act.elapsedTime = 0;
                    act.remainingTime = act.duration * 60;
                });
                currentActivityIndex = 0;
                document.getElementById("activityLabel").innerText = "Timer Reset";
                document.getElementById("activityLabel").style.backgroundColor = "yellow";
                document.getElementById("digitalTimer").innerText = "";
                document.getElementById("resumeBtn").style.display = "none";
                document.getElementById("pauseBtn").style.display = "inline-block";
                document.getElementById("skipBtn").style.display = "none";
                document.getElementById("startBtn").style.display = "inline-block";
                updateActivityKey();
                updateClockDisplay();
                
                // Hide next activity indicator
                document.getElementById("nextActivityContainer").style.display = "none";
            }
            
            // Exit focus mode on reset
            if (inFocusMode) {
                toggleFocusMode();
            }
        }

        function saveActivities() {
            try {
                localStorage.setItem("activities", JSON.stringify(activities));
                alert("Activities saved!");
            } catch (error) {
                console.error("Error saving activities:", error);
                alert("Could not save activities. Error: " + error.message);
            }
        }

        function loadActivities() {
            try {
                const saved = localStorage.getItem("activities");
                if (saved) {
                    activities = JSON.parse(saved);
                    // Reset start times and completed status
                    activities.forEach(act => {
                        if (act.startTime) {
                            act.startTime = new Date(act.startTime);
                        }
                        act.completed = false;
                        // Make sure all activities have the remainingTime property
                        if (typeof act.remainingTime === 'undefined') {
                            act.remainingTime = act.duration * 60;
                        }
                        // Make sure all activities have the elapsedTime property
                        if (typeof act.elapsedTime === 'undefined') {
                            act.elapsedTime = 0;
                        }
                    });
                    updateActivityKey();
                    updateClockDisplay();
                } else {
                    alert("No saved activities found.");
                }
            } catch (error) {
                console.error("Error loading activities:", error);
                alert("Could not load activities. Error: " + error.message);
            }
        }

        // Drag and Drop functionality
        function setupDragAndDrop() {
            const table = document.getElementById("activitiesTable");
            if (!table) return;
            
            const rows = table.querySelectorAll('.draggable-row');
            
            rows.forEach(row => {
                const dragHandle = row.querySelector('.drag-handle');
                
                dragHandle.addEventListener('mousedown', function(e) {
                    // Prevent text selection during drag
                    e.preventDefault();
                    
                    // Get the index of the row
                    dragStartIndex = parseInt(row.getAttribute('data-index'));
                    
                    // Add dragging class
                    row.classList.add('dragging');
                    
                    // Add event listeners for mouse movement and release
                    document.addEventListener('mousemove', handleDrag);
                    document.addEventListener('mouseup', stopDrag);
                });
                
                // Touch support
                dragHandle.addEventListener('touchstart', function(e) {
                    // Get the index of the row
                    dragStartIndex = parseInt(row.getAttribute('data-index'));
                    
                    // Add dragging class
                    row.classList.add('dragging');
                    
                    // Add event listeners for touch movement and end
                    document.addEventListener('touchmove', handleTouchDrag);
                    document.addEventListener('touchend', stopDrag);
                });
            });
        }

        function handleDrag(e) {
            const draggingRow = document.querySelector('.dragging');
            if (!draggingRow) return;
            
            const table = document.getElementById("activitiesTable");
            const rows = Array.from(table.querySelectorAll('.draggable-row'));
            
            // Find the row the cursor is over
            let closest = null;
            let closestDistance = Infinity;
            
            rows.forEach(row => {
                if (row === draggingRow) return;
                
                const rect = row.getBoundingClientRect();
                const rowMiddle = rect.top + rect.height / 2;
                const distance = Math.abs(e.clientY - rowMiddle);
                
                // If this row is closer than the previous closest, update
                if (distance < closestDistance) {
                    closest = row;
                    closestDistance = distance;
                }
            });
            
            if (closest) {
                const closestIndex = parseInt(closest.getAttribute('data-index'));
                const rect = closest.getBoundingClientRect();
                const rowMiddle = rect.top + rect.height / 2;
                
                // Determine if we should insert before or after the closest row
                if (e.clientY < rowMiddle) {
                    table.insertBefore(draggingRow, closest);
                } else {
                    table.insertBefore(draggingRow, closest.nextSibling);
                }
                
                // Update data-index attributes after reordering
                updateRowIndices();
            }
        }
        
        function handleTouchDrag(e) {
            // Get the touch position
            const touch = e.touches[0];
            
            // Simulate a mouse event with the touch coordinates
            const mouseEvent = {
                clientX: touch.clientX,
                clientY: touch.clientY
            };
            
            // Use the same handler as mouse drag
            handleDrag(mouseEvent);
        }
        
        function stopDrag() {
            const draggingRow = document.querySelector('.dragging');
            if (!draggingRow) return;
            
            // Remove the dragging class
            draggingRow.classList.remove('dragging');
            
            // Get the new index of the row
            const dragEndIndex = parseInt(draggingRow.getAttribute('data-index'));
            
            // If the position changed, update the activities array
            if (dragStartIndex !== dragEndIndex) {
                // Move the activity in the array
                const [movedActivity] = activities.splice(dragStartIndex, 1);
                activities.splice(dragEndIndex, 0, movedActivity);
                
                // Update the view
                updateActivityKey();
                updateClockDisplay();
                
                // Update current activity index if needed
                if (isRunning) {
                    if (currentActivityIndex === dragStartIndex) {
                        currentActivityIndex = dragEndIndex;
                    } else if (dragStartIndex < currentActivityIndex && currentActivityIndex <= dragEndIndex) {
                        currentActivityIndex--;
                    } else if (dragStartIndex > currentActivityIndex && currentActivityIndex >= dragEndIndex) {
                        currentActivityIndex++;
                    }
                }
                
                // Update next activity indicator if needed
                updateNextActivityIndicator();
            }
            
            // Remove event listeners
            document.removeEventListener('mousemove', handleDrag);
            document.removeEventListener('mouseup', stopDrag);
            document.removeEventListener('touchmove', handleTouchDrag);
            document.removeEventListener('touchend', stopDrag);
        }
        
        function updateRowIndices() {
            const table = document.getElementById("activitiesTable");
            const rows = Array.from(table.querySelectorAll('.draggable-row'));
            
            rows.forEach((row, index) => {
                row.setAttribute('data-index', index);
            });
        }
        
        // Color Palette Functions
        function openColorModal() {
            document.getElementById('colorModal').style.display = 'block';
        }
        
        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }
        
        function generateColorPalette() {
            const baseColor = document.getElementById('baseColor').value;
            const harmonyType = document.getElementById('harmonyType').value;
            
            const palette = generateHarmony(baseColor, harmonyType);
            colorPalette = palette;
            
            // Save to local storage
            localStorage.setItem('colorPalette', JSON.stringify(colorPalette));
            
            // Update the color palette display
            displayColorPalette(palette);
            
            // Update activities colors if needed
            if (activities.length > 0) {
                activities.forEach((activity, index) => {
                    activity.color = palette[index % palette.length];
                });
                updateActivityKey();
                updateClockDisplay();
            }
        }
        
        function displayColorPalette(palette) {
            const container = document.getElementById('colorPalette');
            container.innerHTML = '';
            
            palette.forEach((color, index) => {
                const colorDiv = document.createElement('div');
                colorDiv.className = 'color-option';
                colorDiv.style.backgroundColor = color;
                colorDiv.title = color;
                colorDiv.setAttribute('data-color', color);
                
                colorDiv.addEventListener('click', () => {
                    selectColor(colorDiv);
                });
                
                container.appendChild(colorDiv);
            });
        }
        
        function selectColor(element) {
            // Remove selected class from all colors
            document.querySelectorAll('.color-option').forEach(el => {
                el.classList.remove('selected');
            });
            
            // Add selected class to clicked color
            element.classList.add('selected');
        }
        
        // For picking a color for a specific activity
        function openColorPickerForActivity(activityIndex) {
            // Store the activity index for later use
            window.currentEditingActivity = activityIndex;
            
            // Open the color modal
            openColorModal();
            
            // Add event listener for color selection
            document.querySelectorAll('.color-option').forEach(option => {
                option.addEventListener('click', function() {
                    const color = this.getAttribute('data-color');
                    updateActivityColor(window.currentEditingActivity, color);
                    closeModal('colorModal');
                }, { once: true });
            });
        }
        
        function updateActivityColor(index, color) {
            if (index >= 0 && index < activities.length) {
                activities[index].color = color;
                updateActivityKey();
                updateClockDisplay();
            }
        }
        
        // Color Utilities
        function hexToRgb(hex) {
            // Remove # if present
            hex = hex.replace('#', '');
            
            // Parse hex values
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            
            return { r, g, b };
        }
        
        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                
                h /= 6;
            }
            
            h = Math.round(h * 360);
            s = Math.round(s * 100);
            l = Math.round(l * 100);
            
            return { h, s, l };
        }
        
        function hslToRgb(h, s, l) {
            h /= 360;
            s /= 100;
            l /= 100;
            
            let r, g, b;
            
            if (s === 0) {
                r = g = b = l; // achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            return {
                r: Math.round(r * 255),
                g: Math.round(g * 255),
                b: Math.round(b * 255)
            };
        }
        
        function rgbToHex(r, g, b) {
            return '#' + 
                ((1 << 24) + (r << 16) + (g << 8) + b)
                .toString(16)
                .slice(1);
        }
        
        function hexToHsl(hex) {
            const rgb = hexToRgb(hex);
            return rgbToHsl(rgb.r, rgb.g, rgb.b);
        }
        
        function hslToHex(h, s, l) {
            const rgb = hslToRgb(h, s, l);
            return rgbToHex(rgb.r, rgb.g, rgb.b);
        }
        
        function generateHarmony(baseColor, harmonyType) {
            const hsl = hexToHsl(baseColor);
            const { h, s, l } = hsl;
            
            let colors = [];
            
            switch (harmonyType) {
                case 'monochromatic':
                    colors = [
                        hslToHex(h, s, l),
                        hslToHex(h, s * 0.7, l),
                        hslToHex(h, s, l * 0.8),
                        hslToHex(h, s * 0.7, l * 1.2),
                        hslToHex(h, s * 1.3, l * 0.8),
                        hslToHex(h, s * 1.3, l * 1.2)
                    ];
                    break;
                    
                case 'analogous':
                    colors = [
                        hslToHex(h, s, l),
                        hslToHex((h + 30) % 360, s, l),
                        hslToHex((h + 60) % 360, s, l),
                        hslToHex((h - 30 + 360) % 360, s, l),
                        hslToHex((h - 60 + 360) % 360, s, l),
                        hslToHex(h, s * 0.8, l * 1.2)
                    ];
                    break;
                    
                case 'triadic':
                    colors = [
                        hslToHex(h, s, l),
                        hslToHex((h + 120) % 360, s, l),
                        hslToHex((h + 240) % 360, s, l),
                        hslToHex(h, s * 0.8, l * 1.2),
                        hslToHex((h + 120) % 360, s * 0.8, l * 1.2),
                        hslToHex((h + 240) % 360, s * 0.8, l * 1.2)
                    ];
                    break;
                    
                case 'tetradic':
                    colors = [
                        hslToHex(h, s, l),
                        hslToHex((h + 90) % 360, s, l),
                        hslToHex((h + 180) % 360, s, l),
                        hslToHex((h + 270) % 360, s, l),
                        hslToHex(h, s * 0.8, l * 1.2),
                        hslToHex((h + 180) % 360, s * 0.8, l * 1.2)
                    ];
                    break;
                    
                default:
                    colors = [...DEFAULT_COLORS];
            }
            
            return colors;
        }
        
        // Sound Options Functions
        function populateSoundOptions() {
            const soundList = document.getElementById('soundList');
            const sounds = [
                { id: 'chimeSound', name: 'Digital Chime' },
                { id: 'bellSound', name: 'Bell' },
                { id: 'beepSound', name: 'Beep' },
                { id: 'alarmSound', name: 'Alarm Clock' },
                { id: 'notificationSound', name: 'Notification' }
            ];
            
            soundList.innerHTML = '';
            
            sounds.forEach(sound => {
                const option = document.createElement('div');
                option.className = `sound-option ${sound.id === selectedSound ? 'selected' : ''}`;
                option.setAttribute('data-sound-id', sound.id);
                option.innerHTML = `
                    <span>${sound.name}</span>
                    <button onclick="previewSound('${sound.id}')">Preview</button>
                `;
                
                option.addEventListener('click', function(e) {
                    if (e.target.tagName !== 'BUTTON') {
                        selectSound(sound.id);
                    }
                });
                
                soundList.appendChild(option);
            });
        }
        
        function openSoundModal() {
            document.getElementById('soundModal').style.display = 'block';
        }
        
        function previewSound(soundId) {
            playSound(soundId);
        }
        
        function selectSound(soundId) {
            selectedSound = soundId;
            localStorage.setItem('selectedSound', soundId);
            
            // Update selected class
            document.querySelectorAll('.sound-option').forEach(option => {
                option.classList.toggle('selected', option.getAttribute('data-sound-id') === soundId);
            });
        }
        
        // Preset Management Functions
        function openPresetsModal() {
            document.getElementById('presetsModal').style.display = 'block';
            loadPresets();
        }
        
        function saveAsPreset() {
            if (activities.length === 0) {
                alert("Please add at least one activity before saving a preset.");
                return;
            }
            
            const presetName = document.getElementById('newPresetName').value.trim();
            if (!presetName) {
                alert("Please enter a name for your preset.");
                return;
            }
            
            try {
                // Get existing presets
                let presets = {};
                if (localStorage.getItem('timerPresets')) {
                    presets = JSON.parse(localStorage.getItem('timerPresets'));
                }
                
                // Store current activities without runtime data
                const presetActivities = activities.map(act => ({
                    name: act.name,
                    duration: act.duration,
                    color: act.color
                }));
                
                // Add or update preset
                presets[presetName] = presetActivities;
                
                // Save to localStorage
                localStorage.setItem('timerPresets', JSON.stringify(presets));
                
                // Clear input field
                document.getElementById('newPresetName').value = '';
                
                // Reload presets display
                loadPresets();
                
                alert(`Preset "${presetName}" saved successfully!`);
            } catch (error) {
                console.error("Error saving preset:", error);
                alert("Could not save preset. Error: " + error.message);
            }
        }
        
        function loadPresets() {
            const container = document.getElementById('presetContainer');
            const noPresetsMsg = document.getElementById('noPresetsMessage');
            
            try {
                const presets = JSON.parse(localStorage.getItem('timerPresets') || '{}');
                const presetNames = Object.keys(presets);
                
                if (presetNames.length === 0) {
                    noPresetsMsg.style.display = 'block';
                    container.innerHTML = '';
                    return;
                }
                
                noPresetsMsg.style.display = 'none';
                container.innerHTML = '';
                
                presetNames.forEach(name => {
                    const presetBox = document.createElement('div');
                    presetBox.className = 'preset-box';
                    
                    const activitiesCount = presets[name].length;
                    const totalDuration = presets[name].reduce((sum, act) => sum + act.duration, 0);
                    
                    presetBox.innerHTML = `
                        <h4>${name}</h4>
                        <p>${activitiesCount} activities</p>
                        <p>Total: ${totalDuration} min</p>
                        <button class="delete-preset" onclick="deletePreset('${name}', event)">×</button>
                    `;
                    
                    presetBox.addEventListener('click', function(e) {
                        if (e.target.className !== 'delete-preset') {
                            loadPreset(name);
                        }
                    });
                    
                    container.appendChild(presetBox);
                });
            } catch (error) {
                console.error("Error loading presets:", error);
                noPresetsMsg.style.display = 'block';
                container.innerHTML = '';
            }
        }
        
        function loadPreset(presetName) {
            try {
                const presets = JSON.parse(localStorage.getItem('timerPresets') || '{}');
                
                if (!presets[presetName]) {
                    alert(`Preset "${presetName}" not found.`);
                    return;
                }
                
                // Confirm if there are existing activities
                if (activities.length > 0) {
                    if (!confirm(`Load preset "${presetName}"? This will replace your current activities.`)) {
                        return;
                    }
                }
                
                // Reset current state
                resetTimer();
                
                // Load activities from preset
                activities = presets[presetName].map(act => ({
                    ...act,
                    completed: false,
                    startTime: null,
                    elapsedTime: 0,
                    remainingTime: act.duration * 60
                }));
                
                // Update UI
                updateActivityKey();
                updateClockDisplay();
                
                // Close modal
                closeModal('presetsModal');
                
                alert(`Preset "${presetName}" loaded successfully!`);
            } catch (error) {
                console.error("Error loading preset:", error);
                alert("Could not load preset. Error: " + error.message);
            }
        }
        
        function deletePreset(presetName, event) {
            // Stop event propagation to prevent loading the preset
            event.stopPropagation();
            
            if (!confirm(`Delete preset "${presetName}"?`)) {
                return;
            }
            
            try {
                const presets = JSON.parse(localStorage.getItem('timerPresets') || '{}');
                
                if (presets[presetName]) {
                    delete presets[presetName];
                    localStorage.setItem('timerPresets', JSON.stringify(presets));
                }
                
                loadPresets();
            } catch (error) {
                console.error("Error deleting preset:", error);
                alert("Could not delete preset. Error: " + error.message);
            }
        }

        // Import/Export Functions
        function exportActivities() {
            if (activities.length === 0) {
                alert("No activities to export.");
                return;
            }
            
            try {
                // Create a simplified version of the activities for export
                const exportData = activities.map(act => ({
                    name: act.name,
                    duration: act.duration,
                    color: act.color
                }));
                
                // Convert to JSON string
                const jsonData = JSON.stringify(exportData, null, 2);
                
                // Create a data URI
                const dataUri = "data:text/json;charset=utf-8," + encodeURIComponent(jsonData);
                
                // Create a temporary link element
                const link = document.createElement('a');
                link.href = dataUri;
                link.download = "activities-export.json";
                document.body.appendChild(link);
                
                // Trigger download
                link.click();
                
                // Cleanup
                document.body.removeChild(link);
                
            } catch (error) {
                console.error("Error exporting activities:", error);
                alert("Could not export activities. Error: " + error.message);
            }
        }
        
        function importActivities() {
            try {
                // Create a file input element
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                
                input.onchange = e => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        try {
                            const importedData = JSON.parse(event.target.result);
                            
                            // Validate the imported data
                            if (!Array.isArray(importedData)) {
                                throw new Error("Invalid import format: not an array");
                            }
                            
                            // Check if there are existing activities
                            if (activities.length > 0) {
                                if (!confirm("This will replace your current activities. Continue?")) {
                                    return;
                                }
                                resetTimer();
                            }
                            
                            // Process and set the imported activities
                            activities = importedData.map(act => {
                                // Validate each activity
                                if (!act.name || typeof act.duration !== 'number') {
                                    throw new Error("Invalid activity format");
                                }
                                
                                return {
                                    name: act.name,
                                    duration: act.duration,
                                    color: act.color || colorPalette[0],
                                    completed: false,
                                    startTime: null,
                                    elapsedTime: 0,
                                    remainingTime: act.duration * 60
                                };
                            });
                            
                            // Update UI
                            updateActivityKey();
                            updateClockDisplay();
                            
                            alert("Activities imported successfully!");
                        } catch (error) {
                            console.error("Error parsing import file:", error);
                            alert("Error importing activities: " + error.message);
                        }
                    };
                    
                    reader.readAsText(file);
                };
                
                // Trigger file selection
                input.click();
                
            } catch (error) {
                console.error("Error setting up import:", error);
                alert("Could not import activities. Error: " + error.message);
            }
        }
    </script>
<!-- Updated RealFocusTimer.html with performance, UX, and progress bar enhancements -->
<!-- Only the JavaScript section is shown for brevity -->

<script>
    // Existing code remains...

    let clockAnimationFrame;

    function startRealTimeClock() {
        if (clockAnimationFrame) cancelAnimationFrame(clockAnimationFrame);
        function animateClock() {
            if (!isRunning && showRealTimeClock) {
                updateClockDisplay();
                clockAnimationFrame = requestAnimationFrame(animateClock);
            }
        }
        animateClock();
    }

    function stopRealTimeClock() {
        if (clockAnimationFrame) cancelAnimationFrame(clockAnimationFrame);
    }

    // UX: show total time left
    function updateTotalTimeIndicator() {
        const totalTimeContainer = document.getElementById("totalTimeContainer");
        const endTimeContainer = document.getElementById("endTimeContainer");
        if (!totalTimeContainer || !endTimeContainer) return;

        const now = new Date();
        let totalSeconds = activities.reduce((sum, act, idx) => {
            if (idx < currentActivityIndex) return sum;
            return sum + (act.remainingTime || act.duration * 60);
        }, 0);

        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;

        totalTimeContainer.innerText = `Time Remaining: ${hours > 0 ? hours + 'h ' : ''}${minutes}m ${seconds}s`;

        // Estimate end time
        const estimatedEnd = new Date(now.getTime() + totalSeconds * 1000);
        endTimeContainer.innerText = `Estimated End: ${estimatedEnd.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;

        const progressBar = document.getElementById("overallProgressBar");
        const totalPlanned = activities.reduce((sum, act) => sum + act.duration * 60, 0);
        const completedSeconds = totalPlanned - totalSeconds;
        const percentage = Math.min(100, Math.floor((completedSeconds / totalPlanned) * 100));
        progressBar.style.width = percentage + "%";

        totalTimeContainer.style.display = isRunning ? 'block' : 'none';
        endTimeContainer.style.display = isRunning ? 'block' : 'none';
        progressBar.parentElement.style.display = isRunning ? 'block' : 'none';
    }

    // Add `updateTotalTimeIndicator()` in `runActivity`, `pauseTimer`, etc.

    let lastDeletedActivity = null;
    function deleteActivity(index) {
        if (isRunning) {
            alert("Please stop the timer before deleting activities.");
            return;
        }

        lastDeletedActivity = { ...activities[index], index };
        activities.splice(index, 1);
        updateActivityKey();
        updateClockDisplay();

        const undoBanner = document.getElementById("undoBanner");
        undoBanner.style.display = "block";
        clearTimeout(undoBanner.hideTimer);
        undoBanner.hideTimer = setTimeout(() => {
            undoBanner.style.display = "none";
            lastDeletedActivity = null;
        }, 5000);
    }

    function undoDelete() {
        if (!lastDeletedActivity) return;
        activities.splice(lastDeletedActivity.index, 0, lastDeletedActivity);
        updateActivityKey();
        updateClockDisplay();
        lastDeletedActivity = null;
        document.getElementById("undoBanner").style.display = "none";
    }
</script>

<!-- Updated RealFocusTimer.html with performance, UX, progress bar, and end-of-session summary -->
<!-- Only the JavaScript section is shown for brevity -->

<script>
    // Existing code remains...

    let clockAnimationFrame;

    function startRealTimeClock() {
        if (clockAnimationFrame) cancelAnimationFrame(clockAnimationFrame);
        function animateClock() {
            if (!isRunning && showRealTimeClock) {
                updateClockDisplay();
                clockAnimationFrame = requestAnimationFrame(animateClock);
            }
        }
        animateClock();
    }

    function stopRealTimeClock() {
        if (clockAnimationFrame) cancelAnimationFrame(clockAnimationFrame);
    }

    // UX: show total time left
    function updateTotalTimeIndicator() {
        const totalTimeContainer = document.getElementById("totalTimeContainer");
        const endTimeContainer = document.getElementById("endTimeContainer");
        if (!totalTimeContainer || !endTimeContainer) return;

        const now = new Date();
        let totalSeconds = activities.reduce((sum, act, idx) => {
            if (idx < currentActivityIndex) return sum;
            return sum + (act.remainingTime || act.duration * 60);
        }, 0);

        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;

        totalTimeContainer.innerText = `Time Remaining: ${hours > 0 ? hours + 'h ' : ''}${minutes}m ${seconds}s`;

        const estimatedEnd = new Date(now.getTime() + totalSeconds * 1000);
        endTimeContainer.innerText = `Estimated End: ${estimatedEnd.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;

        const progressBar = document.getElementById("overallProgressBar");
        const totalPlanned = activities.reduce((sum, act) => sum + act.duration * 60, 0);
        const completedSeconds = totalPlanned - totalSeconds;
        const percentage = Math.min(100, Math.floor((completedSeconds / totalPlanned) * 100));
        progressBar.style.width = percentage + "%";

        totalTimeContainer.style.display = isRunning ? 'block' : 'none';
        endTimeContainer.style.display = isRunning ? 'block' : 'none';
        progressBar.parentElement.style.display = isRunning ? 'block' : 'none';
    }

    function showSummary() {
        const summaryModal = document.getElementById("summaryModal");
        const summaryList = document.getElementById("summaryList");
        summaryList.innerHTML = "";

        activities.forEach((act, i) => {
            const li = document.createElement("li");
            li.innerHTML = `<strong>${act.name}</strong>: ${act.duration} min - ${act.completed ? '✅ Completed' : '❌ Skipped or Incomplete'}`;
            summaryList.appendChild(li);
        });

        summaryModal.style.display = "block";
    }

    let lastDeletedActivity = null;
    function deleteActivity(index) {
        if (isRunning) {
            alert("Please stop the timer before deleting activities.");
            return;
        }

        lastDeletedActivity = { ...activities[index], index };
        activities.splice(index, 1);
        updateActivityKey();
        updateClockDisplay();

        const undoBanner = document.getElementById("undoBanner");
        undoBanner.style.display = "block";
        clearTimeout(undoBanner.hideTimer);
        undoBanner.hideTimer = setTimeout(() => {
            undoBanner.style.display = "none";
            lastDeletedActivity = null;
        }, 5000);
    }

    function undoDelete() {
        if (!lastDeletedActivity) return;
        activities.splice(lastDeletedActivity.index, 0, lastDeletedActivity);
        updateActivityKey();
        updateClockDisplay();
        lastDeletedActivity = null;
        document.getElementById("undoBanner").style.display = "none";
    }

    // Call this at the end of the last activity in runActivity()
    function endSession() {
        isRunning = false;
        showSummary();
    }
</script>

<!-- Add to HTML body -->
<div id="totalTimeContainer" class="non-essential" style="font-weight: bold; margin: 10px 0; display: none;"></div>
<div id="endTimeContainer" class="non-essential" style="font-style: italic; margin-bottom: 10px; display: none;"></div>
<div class="non-essential" style="height: 12px; width: 90%; max-width: 400px; margin: 0 auto 15px; background: #eee; border-radius: 6px; overflow: hidden; display: none;">
    <div id="overallProgressBar" style="height: 100%; width: 0%; background-color: #66c; transition: width 0.5s;"></div>
</div>
<div id="undoBanner" class="non-essential" style="display: none; background: #ffd; padding: 10px; border: 1px solid #cc0;">
    Activity deleted. <button onclick="undoDelete()">Undo</button>
</div>

<!-- End of session summary modal -->
<div id="summaryModal" class="modal non-essential" style="display: none;">
    <div class="modal-content">
        <span class="close-button" onclick="document.getElementById('summaryModal').style.display='none'">&times;</span>
        <h3>Session Summary</h3>
        <ul id="summaryList"></ul>
    </div>
</div>
<!-- Updated RealFocusTimer.html with localStorage history and printable session summary -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
    function showSummary() {
        const summaryModal = document.getElementById("summaryModal");
        const summaryList = document.getElementById("summaryList");
        const exportBtn = document.getElementById("exportSummaryBtn");
        const saveChartBtn = document.getElementById("saveChartBtn");
        const printBtn = document.getElementById("printSummaryBtn");
        const ctx = document.getElementById("summaryChart").getContext("2d");

        summaryList.innerHTML = "";

        activities.forEach((act, i) => {
            const li = document.createElement("li");
            li.innerHTML = `<strong>${act.name}</strong>: ${act.duration} min - ${act.completed ? '✅ Completed' : '❌ Skipped or Incomplete'}`;
            summaryList.appendChild(li);
        });

        exportBtn.onclick = exportSummary;
        saveChartBtn.onclick = saveChartAsImage;
        printBtn.onclick = printSummary;
        summaryModal.style.display = "block";

        const labels = activities.map(act => act.name);
        const data = activities.map(act => act.duration);
        const bgColors = activities.map(act => act.completed ? '#4caf50' : '#f44336');

        if (window.summaryChart) window.summaryChart.destroy();
        window.summaryChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels,
                datasets: [{
                    label: 'Duration (min)',
                    data,
                    backgroundColor: bgColors
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: { display: false },
                    title: { display: true, text: 'Activity Durations and Status' }
                },
                scales: {
                    y: { beginAtZero: true }
                }
            }
        });

        saveSessionToHistory();
    }

    function exportSummary() {
        const completedCount = activities.filter(act => act.completed).length;
        const totalCount = activities.length;
        const totalMinutes = activities.reduce((sum, act) => sum + act.duration, 0);

        const lines = [
            `Session Summary - ${new Date().toLocaleString()}`,
            `Total Activities: ${totalCount}`,
            `Completed: ${completedCount}`,
            `Total Time Planned: ${totalMinutes} minutes`,
            '',
            'Details:'
        ];

        activities.forEach(act => {
            const actualTime = act.elapsedTime || 0;
            const minutes = Math.floor(actualTime / 60);
            const seconds = actualTime % 60;
            lines.push(`- ${act.name}: ${act.duration} min - ${act.completed ? 'Completed' : 'Incomplete'} - Time Spent: ${minutes}m ${seconds}s`);
        });

        const blob = new Blob([lines.join('\n')], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);

        const link = document.createElement('a');
        link.href = url;
        link.download = `Session_Summary_${new Date().toISOString().slice(0, 10)}.txt`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }

    function saveChartAsImage() {
        const canvas = document.getElementById("summaryChart");
        const image = canvas.toDataURL("image/png");
        const link = document.createElement("a");
        link.href = image;
        link.download = `Activity_Summary_Chart_${new Date().toISOString().slice(0, 10)}.png`;
        link.click();
    }

    function printSummary() {
        const printWindow = window.open('', '_blank');
        const chartImage = document.getElementById("summaryChart").toDataURL("image/png");

        let html = `
            <html><head><title>Session Summary</title></head><body>
            <h2>Session Summary - ${new Date().toLocaleString()}</h2>
            <ul>
        `;

        activities.forEach(act => {
            const minutes = Math.floor((act.elapsedTime || 0) / 60);
            const seconds = (act.elapsedTime || 0) % 60;
            html += `<li><strong>${act.name}</strong>: ${act.duration} min - ${act.completed ? '✅ Completed' : '❌ Incomplete'} - Time Spent: ${minutes}m ${seconds}s</li>`;
        });

        html += `</ul><br><img src="${chartImage}" style="max-width: 100%;"><br></body></html>`;

        printWindow.document.write(html);
        printWindow.document.close();
        printWindow.focus();
        printWindow.print();
        printWindow.close();
    }

    function saveSessionToHistory() {
        const session = {
            timestamp: new Date().toISOString(),
            activities: activities.map(act => ({
                name: act.name,
                duration: act.duration,
                completed: act.completed,
                elapsedTime: act.elapsedTime || 0
            }))
        };

        const history = JSON.parse(localStorage.getItem('sessionHistory') || '[]');
        history.push(session);
        localStorage.setItem('sessionHistory', JSON.stringify(history));
    }
</script>

<!-- Add to HTML body -->
<div id="totalTimeContainer" class="non-essential" style="font-weight: bold; margin: 10px 0; display: none;"></div>
<div id="endTimeContainer" class="non-essential" style="font-style: italic; margin-bottom: 10px; display: none;"></div>
<div class="non-essential" style="height: 12px; width: 90%; max-width: 400px; margin: 0 auto 15px; background: #eee; border-radius: 6px; overflow: hidden; display: none;">
    <div id="overallProgressBar" style="height: 100%; width: 0%; background-color: #66c; transition: width 0.5s;"></div>
</div>
<div id="undoBanner" class="non-essential" style="display: none; background: #ffd; padding: 10px; border: 1px solid #cc0;">
    Activity deleted. <button onclick="undoDelete()">Undo</button>
</div>

<!-- End of session summary modal -->
<div id="summaryModal" class="modal non-essential" style="display: none;">
    <div class="modal-content">
        <span class="close-button" onclick="document.getElementById('summaryModal').style.display='none'">&times;</span>
        <h3>Session Summary</h3>
        <ul id="summaryList"></ul>
        <canvas id="summaryChart" style="max-width: 100%; height: 250px; margin: 20px auto;"></canvas>
        <div style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-top: 15px;">
            <button id="exportSummaryBtn">Export Summary</button>
            <button id="saveChartBtn">Save Chart Image</button>
            <button id="printSummaryBtn">Print Summary</button>
        </div>
    </div>
</div>
<!-- Add this to the HTML in the dark-toggle section -->
<label for="fixedStartToggle" style="margin-left: 15px;"><input type="checkbox" id="fixedStartToggle"> Fixed 12 o'clock Start</label>

<!-- Add these script modifications to the existing JavaScript -->
<script>
// Add these variables to the global variables section
let useFixedStartPosition = false; // Whether to use fixed 12 o'clock start

// Add this to the document.addEventListener("DOMContentLoaded", ...) function
document.getElementById("fixedStartToggle").addEventListener("change", function() {
    toggleFixedStartPosition();
});

// Add this to the loadSavedSettings() function
// Load fixed start position setting
if (localStorage.getItem("useFixedStartPosition") === "true") {
    useFixedStartPosition = true;
    document.getElementById("fixedStartToggle").checked = true;
}

// Add this function to toggle the fixed start position
function toggleFixedStartPosition() {
    useFixedStartPosition = document.getElementById("fixedStartToggle").checked;
    localStorage.setItem("useFixedStartPosition", useFixedStartPosition);
    
    // Update the clock display immediately
    updateClockDisplay();
    
    // If timer is running, redraw with new settings
    if (isRunning) {
        const activity = activities[currentActivityIndex];
        const progress = (activity.duration * 60 - activity.remainingTime) / (activity.duration * 60);
        updateClockDisplay(progress);
    }
}

// Modify the drawActivitySectors function
function drawActivitySectors(currentProgress = 0) {
    if (activities.length === 0) return;
    
    // Start angle depends on setting:
    // -Math.PI/2 is 12 o'clock position
    // For fixed start, always use 12 o'clock
    // For dynamic start, use current time offset when running
    let startAngle = -Math.PI / 2; // Default to 12 o'clock position
    
    // Only apply time-based offset if:
    // 1. Not using fixed start position AND
    // 2. Timer is running
    if (!useFixedStartPosition && isRunning) {
        startAngle += startingAngleOffset;
    }
    
    activities.forEach((activity, index) => {
        let arcLength = (activity.duration / 60) * 2 * Math.PI;
        let endAngle = startAngle + arcLength;

        ctx.beginPath();
        ctx.moveTo(0, 0);
        if (index === currentActivityIndex && isRunning) {
            // For the current activity, we only draw from the current progress point to the end
            // This makes the sector disappear clockwise (from start to end)
            let progressStart = startAngle + arcLength * currentProgress;
            ctx.arc(0, 0, radius - 15, progressStart, endAngle);
            ctx.fillStyle = activity.color;
        } else {
            ctx.arc(0, 0, radius - 15, startAngle, endAngle);
            ctx.fillStyle = activity.color;
            ctx.globalAlpha = activity.completed ? 0.5 : 0.2;
        }
        ctx.closePath();
        ctx.fill();
        ctx.globalAlpha = 1;
        startAngle = endAngle;
    });
}

// Modify the startTimer function
function startTimer() {
    if (isRunning) return;
    if (activities.length === 0) {
        alert("Please add at least one activity first.");
        return;
    }
    
    isRunning = true;
    document.getElementById("resumeBtn").style.display = "none";
    document.getElementById("pauseBtn").style.display = "inline-block";
    document.getElementById("skipBtn").style.display = "inline-block";
    document.getElementById("startBtn").style.display = "none";
    
    // Calculate the starting angle offset based on current time
    // Only if not using fixed start position
    if (!useFixedStartPosition) {
        const now = new Date();
        const minutes = now.getMinutes();
        const seconds = now.getSeconds();
        
        // Convert current time to angle (360 degrees = 60 minutes)
        startingAngleOffset = ((minutes * 60 + seconds) / 3600) * (2 * Math.PI);
    } else {
        // If using fixed start, set offset to 0 (12 o'clock position)
        startingAngleOffset = 0;
    }
    
    // Reset total elapsed time
    totalElapsedTime = 0;
    
    // Set start times for all activities based on now
    let currentStartTime = new Date();
    activities.forEach((activity, index) => {
        activity.startTime = new Date(currentStartTime);
        activity.completed = index < currentActivityIndex;
        activity.elapsedTime = 0;
        activity.remainingTime = activity.duration * 60;
        
        // Add this activity's duration to get the next start time
        currentStartTime = new Date(currentStartTime.getTime() + activity.duration * 60000);
    });
    
    // Update the activity table to show start times
    updateActivityKey();
    
    // Auto-enable focus mode when starting
    if (!inFocusMode) {
        toggleFocusMode();
    }
    
    runActivity(currentActivityIndex);
}
</script>
<!-- PWA Installation Script -->
<script>
// Register Service Worker
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
            .then((registration) => {
                console.log('MyTimer.io PWA registered successfully');
            })
            .catch((error) => {
                console.log('Service Worker registration failed:', error);
            });
    });
}

// Install App Button
let installPrompt;
window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    installPrompt = e;
    showInstallButton();
});

function showInstallButton() {
    const installBtn = document.createElement('button');
    installBtn.innerHTML = '📱 Install MyTimer.io';
    installBtn.style.cssText = `
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 1000;
        padding: 10px 15px;
        background: #4CAF50;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    `;
    
    installBtn.addEventListener('click', async () => {
        if (installPrompt) {
            installPrompt.prompt();
            installPrompt = null;
            installBtn.remove();
        }
    });
    
    document.body.appendChild(installBtn);
    
    // Auto-hide after 15 seconds
    setTimeout(() => {
        if (installBtn.parentNode) {
            installBtn.remove();
        }
    }, 15000);
}
</script>
</body>
</html>