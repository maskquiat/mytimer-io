<!DOCTYPE html>

<html lang="en">
<head>
   <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-18XR8R8MFP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

gtag(‚Äòconfig‚Äô, ‚ÄòG-18XR8R8MFP‚Äô);
</script>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Multi-Activity Countdown Timer</title>
<style>
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}

```
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
        transition: all 0.3s ease;
        position: relative;
        overflow-x: hidden;
    }

    body::before {
        content: '';
        position: fixed;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: radial-gradient(circle, rgba(255,255,255,0.05) 0%, transparent 70%);
        animation: float 10s ease-in-out infinite;
        z-index: -1;
    }

    @keyframes float {
        0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
        50% { transform: translate(-50%, -50%) rotate(180deg); }
    }

    body.dark-mode {
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    }

    body.dark-mode .main-container {
        background: #1e1e2e;
        box-shadow: 0 25px 60px rgba(0,0,0,0.4);
    }

    body.dark-mode .header {
        background: linear-gradient(45deg, #2c3e50 0%, #34495e 100%);
    }

    body.dark-mode .section {
        background: #252535;
        color: #e0e0e0;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }

    body.dark-mode .section::before {
        background: linear-gradient(45deg, #4facfe, #00f2fe);
    }

    body.dark-mode .activity-key {
        background: #252535;
        color: #e0e0e0;
    }

    body.dark-mode .stats-panel {
        background: #252535;
        color: #e0e0e0;
    }

    body.dark-mode .stat-card {
        background: #2a2a3e;
        border: 1px solid #3a3a4e;
    }

    body.dark-mode .stat-value {
        color: #4facfe;
    }

    body.dark-mode .stat-label {
        color: #b0b0b0;
    }

    body.dark-mode h3 {
        color: #e0e0e0;
    }

    body.dark-mode p {
        color: #b0b0b0;
    }

    body.dark-mode table {
        color: #e0e0e0;
    }

    body.dark-mode th {
        background: #2a2a3e;
        color: #4facfe;
    }

    body.dark-mode td {
        background: #252535;
        border-color: #3a3a4e;
    }

    body.dark-mode tr:hover td {
        background: #2a2a3e;
    }

    body.dark-mode button {
        background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        color: white;
    }

    body.dark-mode .btn-secondary {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }

    body.dark-mode .btn-danger {
        background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
    }

    body.dark-mode #activityLabel {
        background: rgba(79, 172, 254, 0.2);
        color: #e0e0e0;
        border-color: #4facfe;
    }

    body.dark-mode #digitalTimer {
        color: #4facfe;
    }

    body.dark-mode .next-activity {
        background: rgba(79, 172, 254, 0.1);
        color: #e0e0e0;
        border-color: #4facfe;
    }

    body.dark-mode .clock-container {
        background: linear-gradient(135deg, #2a2a3e 0%, #1e1e2e 100%);
    }

    body.dark-mode .focus-toggle {
        background: rgba(79, 172, 254, 0.2);
        color: #e0e0e0;
    }

    body.dark-mode .timer-badge {
        background: rgba(79, 172, 254, 0.3);
    }

    body.dark-mode #insights-list > div {
        background: linear-gradient(135deg, #2a2a3e 0%, #1e1e2e 100%) !important;
        color: #e0e0e0 !important;
        border-left-color: #4facfe !important;
    }

    /* Collapse header when timer is running or in focus mode */
    body.timer-running .header,
    body.focus-mode .header {
        padding: 20px 15px;
        transition: all 0.3s ease;
    }

    body.timer-running .header h2,
    body.focus-mode .header h2 {
        font-size: 1.8rem;
        margin-bottom: 5px;
    }

    body.timer-running .header-subtitle,
    body.focus-mode .header-subtitle {
        font-size: 0.9rem;
    }

    body.timer-running .timer-badge,
    body.focus-mode .timer-badge {
        font-size: 0.85rem;
        padding: 8px 15px;
    }

    /* Fix timer badge positioning on mobile */
    @media screen and (max-width: 600px) {
        .timer-badge {
            position: static;
            display: inline-block;
            margin: 0 auto 15px;
        }

        .header {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        body.timer-running .header,
        body.focus-mode .header {
            padding: 15px 10px;
        }

        body.timer-running .header h2,
        body.focus-mode .header h2 {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }

        body.timer-running .header-subtitle,
        body.focus-mode .header-subtitle {
            font-size: 0.8rem;
        }
    }

    body.focus-mode .non-essential {
        display: none !important;
    }

    body.focus-mode .main-container {
        max-width: 1200px;
    }

    body.focus-mode .main-content {
        grid-template-columns: 1fr;
        max-width: 900px;
        margin: 0 auto;
        padding: 30px;
    }

    body.focus-mode .clock-container {
        max-width: 500px;
        max-height: 500px;
        margin: 20px auto;
    }

    body.focus-mode #digitalTimer {
        font-size: 3.5rem;
    }

    body.focus-mode #activityLabel {
        font-size: 1.6em;
        padding: 15px 25px;
        margin: 20px auto;
    }

    body.focus-mode .controls {
        max-width: 600px;
        margin: 25px auto;
        gap: 8px;
    }

    body.focus-mode .controls button {
        padding: 12px 20px;
        font-size: 1rem;
        min-width: 100px;
    }

    body.focus-mode .focus-toggle {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 100;
        opacity: 0.8;
    }

    body.focus-mode .focus-toggle:hover {
        opacity: 1;
    }

    /* Feedback Button Styling */
    .feedback-button {
        position: fixed;
        bottom: 100px;
        right: 30px;
        background: linear-gradient(45deg, #ff6b6b, #ee5a6f);
        border: none;
        border-radius: 50%;
        width: 60px;
        height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        color: white;
        box-shadow: 0 8px 25px rgba(255, 107, 107, 0.4);
        z-index: 100;
    }

    .feedback-button:hover {
        transform: scale(1.1);
        box-shadow: 0 12px 35px rgba(255, 107, 107, 0.5);
    }

    body.dark-mode .feedback-button {
        background: linear-gradient(45deg, #ff6b6b, #ee5a6f);
    }

    .main-container {
        max-width: 1400px;
        margin: 0 auto;
        background: white;
        border-radius: 25px;
        box-shadow: 0 25px 60px rgba(0,0,0,0.15);
        overflow: hidden;
        animation: slideUp 0.8s ease-out;
        position: relative;
    }

    @keyframes slideUp {
        from { transform: translateY(40px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
    }

    .header {
        background: linear-gradient(45deg, #4facfe 0%, #00f2fe 100%);
        color: white;
        padding: 10px;
        text-align: center;
        position: relative;
        overflow: hidden;
    }

    .header::before {
        content: '';
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
        animation: headerFloat 8s ease-in-out infinite;
    }

    @keyframes headerFloat {
        0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
        50% { transform: translate(-50%, -50%) rotate(90deg); }
    }

    .header h2 {
        font-size: 3rem;
        margin-bottom: 5px;
        font-weight: 700;
        position: relative;
        z-index: 2;
        text-shadow: 0 4px 15px rgba(0,0,0,0.2);
        animation: pulse 3s infinite;
    }

    .header-subtitle {
        font-size: 1.3rem;
        opacity: 0.9;
        position: relative;
        z-index: 2;
    }

    .timer-badge {
        position: absolute;
        top: 25px;
        right: 25px;
        background: rgba(255,255,255,0.2);
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 0.9rem;
        backdrop-filter: blur(15px);
        border: 1px solid rgba(255,255,255,0.1);
        z-index: 3;
        font-weight: 600;
    }

    @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.05); }
    }

    .main-content {
        display: block;
        max-width: 1200px;
        margin: 0 auto;
        padding: 10px;
    }

    .left-panel {
        display: flex;
        flex-direction: column;
        gap: 0px;
    }

    .section {
        background: white;
        padding: 5px;
        border-radius: 20px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        margin-bottom: 30px;
        position: relative;
        overflow: hidden;
        transition: all 0.3s ease;
    }

    .section:hover {
        transform: translateY(-2px);
        box-shadow: 0 15px 40px rgba(0,0,0,0.15);
    }

    .section::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 5px;
        background: linear-gradient(45deg, #4facfe, #00f2fe);
    }

    .clock-container {
        width: 90vw;
        max-width: 400px;
        height: 90vw;
        max-height: 400px;
        position: relative;
        margin: 30px auto;
        transition: all 0.3s ease;
        border-radius: 50%;
        background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        padding: 20px;
        box-shadow: 0 20px 40px rgba(0,0,0,0.1);
    }

    #analogClock {
        width: 100%;
        height: 100%;
        border: 8px solid transparent;
        border-radius: 50%;
        background: linear-gradient(white, white) padding-box,
                    linear-gradient(45deg, #4facfe, #00f2fe) border-box;
        box-shadow: inset 0 0 30px rgba(79, 172, 254, 0.1);
    }

    body.dark-mode #analogClock {
        background: linear-gradient(#333, #333) padding-box,
                    linear-gradient(45deg, #4facfe, #00f2fe) border-box;
        box-shadow: inset 0 0 30px rgba(79, 172, 254, 0.2);
    }

    .toggle-container {
        display: flex;
        gap: 30px;
        justify-content: center;
        align-items: center;
        background: white;
        padding: 10px 30px;
        border-radius: 15px;
        box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        margin-bottom: 20px;
    }

    body.dark-mode .toggle-container {
        background: #333;
        box-shadow: 0 8px 25px rgba(0,0,0,0.3);
    }

    .toggle-item {
        display: flex;
        align-items: center;
        gap: 10px;
        position: relative;
    }

    .toggle-item input[type="checkbox"] {
        appearance: none;
        width: 50px;
        height: 26px;
        background: #ddd;
        border-radius: 13px;
        position: relative;
        cursor: pointer;
        transition: all 0.3s ease;
    }

    .toggle-item input[type="checkbox"]:checked {
        background: linear-gradient(45deg, #4facfe, #00f2fe);
    }

    .toggle-item input[type="checkbox"]::before {
        content: '';
        position: absolute;
        width: 22px;
        height: 22px;
        border-radius: 50%;
        background: white;
        top: 2px;
        left: 2px;
        transition: all 0.3s ease;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }

    .toggle-item input[type="checkbox"]:checked::before {
        left: 26px;
    }

    .toggle-item label {
        font-weight: 600;
        color: #333;
        cursor: pointer;
    }

    body.dark-mode .toggle-item label {
        color: #fff;
    }

    #activityLabel {
        font-weight: bold;
        background: linear-gradient(45deg, #ffd700, #ffed4e);
        padding: 15px 25px;
        display: inline-block;
        border-radius: 15px;
        font-size: 1.3rem;
        margin: 20px auto;
        text-align: center;
        box-shadow: 0 8px 25px rgba(255, 215, 0, 0.3);
        transition: all 0.3s ease;
        animation: labelGlow 2s ease-in-out infinite alternate;
    }

    @keyframes labelGlow {
        from { box-shadow: 0 8px 25px rgba(255, 215, 0, 0.3); }
        to { box-shadow: 0 12px 35px rgba(255, 215, 0, 0.5); }
    }

    #digitalTimer {
        font-size: 3rem;
        font-weight: 700;
        color: #667eea;
        text-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        margin: 20px 0;
        text-align: center;
        transition: all 0.3s ease;
    }

    .controls {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 8px;
        margin: 20px 0;
    }

    .controls button, .feature-container button {
        padding: 10px 16px;
        border: none;
        border-radius: 12px;
        font-size: 0.95rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
        min-width: 90px;
    }

    .controls button::before, .feature-container button::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
        transition: left 0.5s ease;
    }

    .controls button:hover::before, .feature-container button:hover::before {
        left: 100%;
    }

    .btn-primary {
        background: linear-gradient(45deg, #667eea, #764ba2);
        color: white;
        box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
    }

    .btn-primary:hover {
        transform: translateY(-3px);
        box-shadow: 0 12px 35px rgba(102, 126, 234, 0.4);
    }

    .btn-secondary {
        background: linear-gradient(45deg, #84fab0, #8fd3f4);
        color: white;
        box-shadow: 0 8px 25px rgba(132, 250, 176, 0.3);
    }

    .btn-secondary:hover {
        transform: translateY(-3px);
        box-shadow: 0 12px 35px rgba(132, 250, 176, 0.4);
    }

    .btn-danger {
        background: linear-gradient(45deg, #ff4757, #ff6b7a);
        color: white;
        box-shadow: 0 8px 25px rgba(255, 71, 87, 0.3);
    }

    .btn-danger:hover {
        transform: translateY(-3px);
        box-shadow: 0 12px 35px rgba(255, 71, 87, 0.4);
    }

    .feature-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 8px;
        margin: 20px 0;
    }

    .activity-key {
        margin-top: 30px;
        padding: 30px;
        background: white;
        border-radius: 20px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.1);
    }

    .activity-key h3 {
        color: #333;
        margin-bottom: 20px;
        font-size: 1.5rem;
        text-align: center;
    }

    .activity-key table {
        border-collapse: collapse;
        width: 100%;
        margin: auto;
        background: white;
        border-radius: 15px;
        overflow: hidden;
        box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }

    .activity-key th {
        background: linear-gradient(45deg, #667eea, #764ba2);
        color: white;
        padding: 15px;
        font-weight: 600;
        text-align: left;
    }

    .activity-key td {
        padding: 12px 15px;
        border-bottom: 1px solid #f0f0f0;
        transition: all 0.3s ease;
    }

    .activity-key tr:hover td {
        background: linear-gradient(135deg, #f8f9ff 0%, #e8f4fd 100%);
    }

    .color-box {
        width: 25px;
        height: 25px;
        display: inline-block;
        cursor: pointer;
        border-radius: 8px;
        border: 2px solid white;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        transition: all 0.3s ease;
    }

    .color-box:hover {
        transform: scale(1.1);
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    .draggable-row {
        cursor: move;
        transition: all 0.3s ease;
    }

    .draggable-row.dragging {
        opacity: 0.7;
        transform: scale(1.02);
        background: linear-gradient(135deg, #f8f9ff 0%, #e8f4fd 100%);
    }

    .drag-handle {
        cursor: move;
        padding: 8px;
        user-select: none;
        color: #667eea;
        font-size: 1.2rem;
        transition: all 0.3s ease;
    }

    .drag-handle:hover {
        color: #4facfe;
        transform: scale(1.1);
    }

    .drag-handle::before {
        content: "‚ò∞";
    }

    .focus-toggle {
        background: linear-gradient(45deg, #667eea, #764ba2);
        border: none;
        border-radius: 50%;
        width: 60px;
        height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        color: white;
        box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        position: fixed;
        bottom: 30px;
        right: 30px;
        z-index: 100;
    }

    .focus-toggle:hover {
        transform: scale(1.1);
        box-shadow: 0 12px 35px rgba(102, 126, 234, 0.4);
    }

    .next-activity {
        padding: 15px 25px;
        border-radius: 15px;
        margin: 20px auto;
        display: inline-block;
        font-weight: bold;
        background: linear-gradient(45deg, #84fab0, #8fd3f4);
        color: white;
        box-shadow: 0 8px 25px rgba(132, 250, 176, 0.3);
        transition: all 0.3s ease;
        opacity: 0;
        text-align: center;
    }

    body.focus-mode .next-activity {
        opacity: 1;
    }

    /* Modal Styles */
    .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(5px);
    }

    .modal-content {
        background: white;
        margin: 5% auto;
        padding: 40px;
        border: none;
        width: 90%;
        max-width: 700px;
        border-radius: 25px;
        box-shadow: 0 25px 60px rgba(0,0,0,0.3);
        animation: modalSlideIn 0.3s ease-out;
        max-height: 85vh;
        overflow-y: auto;
    }

    @keyframes modalSlideIn {
        from { opacity: 0; transform: translateY(-50px); }
        to { opacity: 1; transform: translateY(0); }
    }

    body.dark-mode .modal-content {
        background: #333;
        color: white;
    }

    .close-button {
        color: #aaa;
        float: right;
        font-size: 32px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
    }

    .close-button:hover {
        color: #ff4757;
        transform: scale(1.1);
    }

    /* Progress Indicators */
    .progress-container {
        background: #f0f0f0;
        height: 15px;
        border-radius: 10px;
        margin: 20px 0;
        overflow: hidden;
        box-shadow: inset 0 2px 5px rgba(0,0,0,0.1);
    }

    .progress-bar {
        height: 100%;
        background: linear-gradient(45deg, #4facfe, #00f2fe);
        border-radius: 10px;
        transition: width 0.5s ease;
        box-shadow: 0 2px 10px rgba(79, 172, 254, 0.4);
    }

    /* Notification Styles */
    .notification {
        position: fixed;
        top: 30px;
        right: 30px;
        background: linear-gradient(45deg, #4facfe, #00f2fe);
        color: white;
        padding: 20px 30px;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(79, 172, 254, 0.4);
        transform: translateX(400px);
        transition: transform 0.3s ease;
        z-index: 1001;
        font-weight: 600;
        max-width: 300px;
    }

    .notification.show {
        transform: translateX(0);
    }

    /* Statistics Panel */
    .stats-panel {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 25px;
        border-radius: 20px;
        margin-bottom: 25px;
        position: relative;
        overflow: hidden;
    }

    .stats-panel::before {
        content: '';
        position: absolute;
        top: -50%;
        right: -50%;
        width: 200%;
        height: 200%;
        background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
        animation: rotate 12s linear infinite;
    }

    @keyframes rotate {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .stats-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        position: relative;
        z-index: 2;
    }

    .stat-card {
        background: rgba(255,255,255,0.1);
        padding: 20px;
        border-radius: 15px;
        backdrop-filter: blur(15px);
        border: 1px solid rgba(255,255,255,0.1);
        text-align: center;
    }

    .stat-value {
        font-size: 2rem;
        font-weight: bold;
        color: #00f2fe;
        text-shadow: 0 2px 10px rgba(0, 242, 254, 0.3);
    }

    .stat-label {
        font-size: 0.9rem;
        opacity: 0.9;
        margin-top: 5px;
    }

    /* CRITICAL MOBILE FIXES */
    @media screen and (max-width: 768px) {
        body {
            padding: 10px;
        }

        .main-container {
            border-radius: 15px;
        }

        .header {
            padding: 25px 15px;
        }

        .header h2 {
            font-size: 2rem;
        }

        .main-content {
            padding: 15px 10px;
        }
```

.btn-quickstart {
background: linear-gradient(45deg, #4facfe, #00f2fe) !important;
animation: pulse 2s infinite;
font-weight: 700 !important;
}

@keyframes pulse {
0%, 100% { transform: scale(1); }
50% { transform: scale(1.05); }
}

```
        /* Feedback button mobile positioning */
        .feedback-button {
            bottom: 90px;
            right: 20px;
            width: 50px;
            height: 50px;
        }

        /* Toggle Container - All 3 visible */
        .toggle-container {
            flex-direction: column !important;
            gap: 12px !important;
            padding: 10px !important;
            align-items: center !important;
            width: 100% !important;
            box-sizing: border-box !important;
        }

        .toggle-item {
            width: 100% !important;
            max-width: 300px !important;
            justify-content: space-between !important;
            padding: 12px 15px !important;
            background: white !important;
            border-radius: 10px !important;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08) !important;
            display: flex !important;
            box-sizing: border-box !important;
        }

        body.dark-mode .toggle-item {
            background: #333 !important;
        }

        .toggle-item label {
            font-size: 0.9rem !important;
            white-space: nowrap !important;
        }

        /* Clock */
        .clock-container {
            width: 85vw !important;
            max-width: 320px !important;
            height: 85vw !important;
            max-height: 320px !important;
            padding: 15px !important;
            margin: 20px auto !important;
        }

        /* Activity Label */
        #activityLabel {
            font-size: clamp(1rem, 4vw, 1.2rem) !important;
            padding: 12px 15px !important;
            margin: 15px auto !important;
            width: 95% !important;
            max-width: 100% !important;
            text-align: center !important;
            display: block !important;
            word-wrap: break-word !important;
            box-sizing: border-box !important;
        }

        #digitalTimer {
            font-size: clamp(1.8rem, 8vw, 2.5rem) !important;
            text-align: center !important;
        }

        .next-activity {
            font-size: 0.9rem !important;
            padding: 12px 15px !important;
            width: 95% !important;
            max-width: 100% !important;
            margin: 15px auto !important;
            text-align: center !important;
            box-sizing: border-box !important;
        }

        /* Controls */
        .controls {
            flex-direction: column !important;
            align-items: center !important;
            gap: 10px !important;
            padding: 0 10px !important;
        }

        .controls button, .feature-container button {
            width: 100% !important;
            max-width: 300px !important;
            font-size: 0.9rem !important;
            padding: 12px !important;
            box-sizing: border-box !important;
        }

        .feature-container {
            flex-direction: column !important;
            align-items: center !important;
            gap: 10px !important;
            padding: 0 10px !important;
        }

        /* CRITICAL FIX: Activity Timeline - properly contained */
        .activity-key {
            padding: 15px 10px !important;
            margin: 20px 0 !important;
            width: 100% !important;
            box-sizing: border-box !important;
            overflow: hidden !important;
        }

        .activity-key h3 {
            font-size: 1.2rem !important;
            margin-bottom: 12px !important;
        }

        .activity-key p {
            font-size: 0.85rem !important;
            padding: 0 5px !important;
        }

        /* Table wrapper for horizontal scroll */
        .activity-key table {
            display: block !important;
            width: 100% !important;
            overflow-x: auto !important;
            -webkit-overflow-scrolling: touch !important;
            font-size: 0.75rem !important;
        }

        .activity-key thead,
        .activity-key tbody,
        .activity-key tr {
            display: table !important;
            width: 100% !important;
            table-layout: fixed !important;
        }

        .activity-key th,
        .activity-key td {
            padding: 8px 5px !important;
            font-size: 0.75rem !important;
            white-space: nowrap !important;
            overflow: hidden !important;
            text-overflow: ellipsis !important;
        }

        .activity-key th:first-child,
        .activity-key td:first-child {
            width: 30px !important;
        }

        .activity-key th:nth-child(2),
        .activity-key td:nth-child(2) {
            width: 40px !important;
        }

        .activity-key button {
            padding: 4px 8px !important;
            font-size: 0.7rem !important;
        }

        .drag-handle {
            font-size: 1rem !important;
            padding: 4px !important;
        }

        .color-box {
            width: 20px !important;
            height: 20px !important;
        }

        /* CRITICAL FIX: Session Stats - single column */
        .stats-panel {
            padding: 15px 10px !important;
            margin: 20px 0 !important;
            width: 100% !important;
            box-sizing: border-box !important;
        }

        .stats-panel h3 {
            font-size: 1.2rem !important;
            margin-bottom: 15px !important;
        }

        .stats-grid {
            grid-template-columns: 1fr !important;
            gap: 10px !important;
            width: 100% !important;
        }

        .stat-card {
            padding: 12px !important;
            width: 100% !important;
            box-sizing: border-box !important;
        }

        .stat-value {
            font-size: 1.5rem !important;
        }

        .stat-label {
            font-size: 0.8rem !important;
        }

        /* CRITICAL FIX: Smart Insights - properly contained */
        .section {
            padding: 15px 10px !important;
            margin-bottom: 20px !important;
            width: 100% !important;
            box-sizing: border-box !important;
        }

        .section h3 {
            font-size: 1.2rem !important;
            margin-bottom: 12px !important;
        }

        #insights-list {
            width: 100% !important;
            box-sizing: border-box !important;
        }

        #insights-list > div {
            padding: 10px !important;
            font-size: 0.8rem !important;
            word-wrap: break-word !important;
            overflow-wrap: break-word !important;
            margin-bottom: 10px !important;
            width: 100% !important;
            box-sizing: border-box !important;
            line-height: 1.4 !important;
        }

        /* Modal */
        .modal-content {
            width: 95% !important;
            margin: 5% auto !important;
            padding: 20px 15px !important;
            box-sizing: border-box !important;
            max-height: 90vh !important;
        }

        /* Notification */
        .notification {
            top: 10px !important;
            right: 10px !important;
            left: 10px !important;
            max-width: none !important;
            padding: 15px !important;
            font-size: 0.9rem !important;
            box-sizing: border-box !important;
        }

        /* Focus toggle */
        .focus-toggle {
            bottom: 20px !important;
            right: 20px !important;
            width: 50px !important;
            height: 50px !important;
        }
    }

    /* Extra small screens */
    @media screen and (max-width: 400px) {
        .header h2 {
            font-size: 1.6rem !important;
        }

        .clock-container {
            width: 80vw !important;
            max-width: 250px !important;
            height: 80vw !important;
            max-height: 250px !important;
        }

        #digitalTimer {
            font-size: clamp(1.5rem, 7vw, 2rem) !important;
        }

        #activityLabel {
            font-size: 0.95rem !important;
            padding: 10px !important;
        }

        .stat-value {
            font-size: 1.3rem !important;
        }

        .activity-key th,
        .activity-key td {
            font-size: 0.7rem !important;
            padding: 6px 4px !important;
        }

        #insights-list > div {
            font-size: 0.75rem !important;
            padding: 8px !important;
        }
    }

    .hidden {
        display: none;
    }

    /* Sound and color palette styles */
    .color-palette {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 10px;
        margin-top: 20px;
    }

    .color-option {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        cursor: pointer;
        border: 3px solid transparent;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }

    .color-option:hover {
        transform: scale(1.1);
        box-shadow: 0 6px 20px rgba(0,0,0,0.3);
    }

    .color-option.selected {
        border: 3px solid #667eea;
        transform: scale(1.15);
    }

    .sound-option {
        display: flex;
        align-items: center;
        padding: 15px;
        margin: 10px 0;
        border: 2px solid #f0f0f0;
        border-radius: 15px;
        cursor: pointer;
        transition: all 0.3s ease;
        background: white;
    }

    .sound-option:hover {
        background: linear-gradient(135deg, #f8f9ff 0%, #e8f4fd 100%);
        border-color: #4facfe;
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(79, 172, 254, 0.2);
    }

    .sound-option.selected {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-color: #667eea;
    }
</style>
```

</head>
<body>
    <div class="main-container">
        <div class="header">
            <h2>üéØ MyTimer.io</h2>
            <p class="header-subtitle">Multi-Activity Timer | Real Time Sync | Increased Awareness</p>
        </div>

```
    <div class="main-content">
        <div class="left-panel">
            <div class="toggle-container non-essential">
                <div class="toggle-item">
                    <input type="checkbox" id="darkModeToggle">
                    <label for="darkModeToggle">Dark Mode</label>
                </div>
                <div class="toggle-item">
                    <input type="checkbox" id="realTimeClockToggle" checked>
                    <label for="realTimeClockToggle">Real-Time Clock</label>
                </div>
                <div class="toggle-item">
                    <input type="checkbox" id="fixedStartToggle">
                    <label for="fixedStartToggle">Fixed 12 O'Clock Start</label>
                </div>
            </div>

            <div class="section">
                <div class="clock-container">
                    <canvas id="analogClock"></canvas>
                </div>
                
                <p id="activityLabel">No Activities Started</p>
                <p id="digitalTimer" aria-live="polite"></p>
                
                <div id="nextActivityContainer" class="next-activity" style="display: none;">
                    Next: <span id="nextActivityLabel"></span>
                </div>

                <div id="totalTimeContainer" class="non-essential" style="font-weight: bold; margin: 20px 0; display: none; text-align: center; color: #667eea;"></div>
                <div id="endTimeContainer" class="non-essential" style="font-style: italic; margin-bottom: 20px; display: none; text-align: center; color: #666;"></div>
                <div class="progress-container non-essential" style="display: none;">
                    <div id="overallProgressBar" class="progress-bar" style="width: 0%;"></div>
                </div>
            </div>

            <div class="controls">
                <button onclick="addActivity()" class="non-essential btn-primary" aria-label="Add Activity">‚ûï Add Activity</button>
                <button onclick="startTimer()" id="startBtn" class="btn-primary" aria-label="Start Timer">üöÄ START</button>
                <button onclick="pauseTimer()" id="pauseBtn" class="btn-secondary" aria-label="Pause Timer">‚è∏Ô∏è Pause</button>
                <button onclick="resumeTimer()" id="resumeBtn" style="display:none;" class="btn-primary" aria-label="Resume Timer">‚ñ∂Ô∏è Resume</button>
                <button onclick="resetTimer()" class="btn-danger" aria-label="Reset Timer">üîÑ Reset</button>
                <button onclick="skipToNext()" id="skipBtn" style="display:none;" class="btn-secondary" aria-label="Skip to Next">‚è≠Ô∏è Skip</button>
            </div>
            
            <div class="feature-container non-essential">
<button onclick="openQuickStartModal()" class="btn-quickstart" style="background: linear-gradient(45deg, #4facfe, #00f2fe); font-size: 1.1rem; padding: 12px 24px;">‚ö° QUICK START</button>
<button onclick="openPresetsModal()" class="btn-primary">üìã Presets</button>
                <button onclick="openColorModal()" class="btn-secondary" aria-label="Choose Colors">üé® Colors</button>
                <button onclick="openSoundModal()" class="btn-primary" aria-label="Select Sounds">üîä Sounds</button>
                <button onclick="exportActivities()" class="btn-secondary" aria-label="Export Activities">üì§ Export</button>
                <button onclick="importActivities()" class="btn-primary" aria-label="Import Activities">üì• Import</button>
            </div>

            <div class="activity-key non-essential" id="activityKey" aria-label="Activity List">
                <h3>Activity Timeline</h3>
                <p style="text-align: center; color: #666; margin-bottom: 20px;">Add activities to see your personalized schedule</p>
            </div>

            <div id="undoBanner" class="non-essential" style="display: none; background: linear-gradient(45deg, #ffd700, #ffed4e); padding: 15px; border-radius: 15px; text-align: center; box-shadow: 0 8px 25px rgba(255, 215, 0, 0.3);">
                Activity deleted. <button onclick="undoDelete()" class="btn-primary" style="margin-left: 10px;">Undo</button>
            </div>

            <!-- Statistics Panel -->
            <div class="stats-panel section non-essential">
                <h3 style="margin-bottom: 20px; position: relative; z-index: 2;">üìä Session Stats</h3>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="totalActivities">0</div>
                        <div class="stat-label">Total Activities</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="completedCount">0</div>
                        <div class="stat-label">Completed</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="totalPlannedTime">0m</div>
                        <div class="stat-label">Planned Time</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="progressStat">0%</div>
                        <div class="stat-label">Progress</div>
                    </div>
                </div>
            </div>

            <!-- Quick Insights -->
            <div class="section non-essential" style="background: white; border: 2px solid #e1e5e9; border-radius: 20px; padding: 25px; margin-bottom: 25px;">
                <h3 style="color: #333; margin-bottom: 20px; display: flex; align-items: center; gap: 10px;">
                    üß† Smart Insights
                </h3>
                <div id="insights-list">
                    <div style="padding: 15px; background: linear-gradient(135deg, #f8f9ff 0%, #e8f4fd 100%); margin-bottom: 12px; border-radius: 12px; border-left: 4px solid #4facfe; font-size: 0.95rem;">
                        üéØ Perfect timing to start your focused work session!
                    </div>
                    <div style="padding: 15px; background: linear-gradient(135deg, #f8f9ff 0%, #e8f4fd 100%); margin-bottom: 12px; border-radius: 12px; border-left: 4px solid #4facfe; font-size: 0.95rem;">
                        ‚ö° Your productivity peaks with timed activities.
                    </div>
                    <div style="padding: 15px; background: linear-gradient(135deg, #f8f9ff 0%, #e8f4fd 100%); margin-bottom: 12px; border-radius: 12px; border-left: 4px solid #4facfe; font-size: 0.95rem;">
                        üìà Break tasks into 25-minute focused sessions.
                    </div>
                </div>
            </div>

            <!-- Quick Actions -->
            <div class="section non-essential" style="display: grid; gap: 15px;">
                <button onclick="showSummary()" class="btn-primary" style="width: 100%;">
                    üìä Session Summary
                </button>
                <button onclick="saveActivities()" class="btn-secondary" style="width: 100%;">
                    üíæ Save Session
                </button>
                <button onclick="loadActivities()" class="btn-primary" style="width: 100%;">
                    üìÇ Load Session
                </button>
            </div>
        </div>

    </div>
</div>

<!-- Feedback Button - Opens Google Form -->
<button class="feedback-button" onclick="openGoogleFeedbackForm()" title="Share Your Feedback">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
    </svg>
</button>

<div class="focus-toggle" onclick="toggleFocusMode()" title="Toggle Focus Mode">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"></path>
        <circle cx="12" cy="12" r="3"></circle>
    </svg>
</div>

<!-- Color Modal -->
<div id="colorModal" class="modal non-essential">
    <div class="modal-content">
        <span class="close-button" onclick="closeModal('colorModal')">&times;</span>
        <h3 style="margin-bottom: 25px; color: #333;">üé® Color Theme Selection</h3>
        <div style="margin-bottom: 20px;">
            <label for="harmonyType" style="font-weight: 600; margin-right: 10px;">Color Harmony: </label>
            <select id="harmonyType" onchange="generateColorPalette()" style="padding: 8px 12px; border-radius: 8px; border: 2px solid #e1e5e9;">
                <option value="monochromatic">Monochromatic</option>
                <option value="analogous">Analogous</option>
                <option value="complementary">Complementary</option>
                <option value="splitComplementary">Split Complementary</option>
                <option value="triadic">Triadic</option>
                <option value="tetradic">Tetradic</option>
            </select>
        </div>
        <div style="margin-bottom: 20px;">
            <label for="baseColor" style="font-weight: 600; margin-right: 10px;">Base Color: </label>
            <input type="color" id="baseColor" value="#3366ff" onchange="generateColorPalette()" style="width: 50px; height: 40px; border: none; border-radius: 8px; cursor: pointer;">
        </div>
        <div class="color-palette" id="colorPalette"></div>
    </div>
</div>

<!-- Sound Modal -->
<div id="soundModal" class="modal non-essential">
    <div class="modal-content">
        <span class="close-button" onclick="closeModal('soundModal')">&times;</span>
        <h3 style="margin-bottom: 25px; color: #333;">üîä Sound Selection</h3>
        <p style="margin-bottom: 20px; color: #666;">Choose a sound to play when an activity completes:</p>
        <div id="soundList"></div>
    </div>
</div>
```

<!-- Quick Start Templates Modal -->

<div id="quickStartModal" class="modal non-essential">
    <div class="modal-content" style="max-width: 1000px;">
        <span class="close-button" onclick="closeModal('quickStartModal')">&times;</span>
        <h3 style="margin-bottom: 10px; color: #333; font-size: 2rem; text-align: center;">‚ö° Quick Start Templates</h3>
        <p style="text-align: center; color: #666; margin-bottom: 30px; font-size: 1.1rem;">
            Beat procrastination! Choose a preset and start immediately.
        </p>

```
    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 20px; margin-top: 30px;" id="quickStartTemplates"></div>
</div>
```

</div>
    <!-- Presets Modal -->
    <div id="presetsModal" class="modal non-essential">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('presetsModal')">&times;</span>
            <h3 style="margin-bottom: 25px; color: #333;">üìã Preset Management</h3>
            <p style="margin-bottom: 20px; color: #666;">Save your current activities as a preset or load a previously saved preset:</p>

```
        <div style="margin-bottom: 25px;">
            <input type="text" id="newPresetName" placeholder="Preset Name (e.g. Morning Routine)" style="padding: 12px 16px; width: 70%; border: 2px solid #e1e5e9; border-radius: 10px; margin-right: 10px;">
            <button onclick="saveAsPreset()" class="btn-primary">Save Current as Preset</button>
        </div>
        
        <h4 style="margin-bottom: 15px; color: #333;">Available Presets</h4>
        <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 15px;" id="presetContainer">
            <p id="noPresetsMessage" style="color: #666; text-align: center;">No saved presets found.</p>
        </div>
    </div>
</div>

<!-- Session Summary Modal -->
<div id="summaryModal" class="modal non-essential">
    <div class="modal-content">
        <span class="close-button" onclick="document.getElementById('summaryModal').style.display='none'">&times;</span>
        <h3 style="margin-bottom: 25px; color: #333;">üìä Session Summary</h3>
        <ul id="summaryList" style="list-style: none; padding: 0;"></ul>
        <canvas id="summaryChart" style="max-width: 100%; height: 300px; margin: 30px auto; display: block; border-radius: 15px;"></canvas>
        <div style="display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; margin-top: 25px;">
            <button id="exportSummaryBtn" class="btn-primary">üì§ Export Summary</button>
            <button id="saveChartBtn" class="btn-secondary">üñºÔ∏è Save Chart</button>
            <button id="printSummaryBtn" class="btn-primary">üñ®Ô∏è Print Summary</button>
        </div>
    </div>
</div>

<div class="notification" id="notification">
    ‚è∞ Timer completed! Time for a break!
</div>

<!-- Audio elements -->
<audio id="chimeSound" src="https://actions.google.com/sounds/v1/alarms/digital_watch_alarm_long.ogg"></audio>
<audio id="bellSound" src="https://actions.google.com/sounds/v1/alarms/medium_bell_ringing_near.ogg"></audio>
<audio id="beepSound" src="https://actions.google.com/sounds/v1/alarms/beep_short.ogg"></audio>
<audio id="alarmSound" src="https://actions.google.com/sounds/v1/alarms/alarm_clock.ogg"></audio>
<audio id="notificationSound" src="https://actions.google.com/sounds/v1/alarms/notification_alert_chord.ogg"></audio>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
    // Constants
    const DEFAULT_COLORS = ["#3366ff", "#33cc33", "#ff6600", "#9933cc", "#cc3366", "#33cccc"];
    const GOOGLE_FORM_URL = "https://docs.google.com/forms/d/e/1FAIpQLSfhVTtcwKAyHiA15UyoRzq9QTaFSNJtUnhqSxTWs8dComILRg/viewform?usp=header";
    
    // Pre-built Quick-Start Templates
    const PRESET_TEMPLATES = {
        "Morning Routine": {
            icon: "üåÖ",
            description: "Start your day with structure",
            activities: [
                { name: "Wake Up & Stretch", duration: 5, color: "#33cc33" },
                { name: "Brush Teeth", duration: 5, color: "#3366ff" },
                { name: "Get Dressed", duration: 10, color: "#ff6600" },
                { name: "Breakfast", duration: 15, color: "#9933cc" },
                { name: "Pack Bag", duration: 5, color: "#cc3366" }
            ]
        },
        "Homework Session": {
            icon: "üìö",
            description: "Focused study time with breaks",
            activities: [
                { name: "Organize Materials", duration: 5, color: "#3366ff" },
                { name: "Math Homework", duration: 25, color: "#ff6600" },
                { name: "Break", duration: 5, color: "#33cc33" },
                { name: "Reading Assignment", duration: 20, color: "#9933cc" },
                { name: "Review & Pack Up", duration: 10, color: "#33cccc" }
            ]
        },
        "Focus Sprint (Pomodoro)": {
            icon: "üçÖ",
            description: "Classic Pomodoro technique",
            activities: [
                { name: "Deep Work Session 1", duration: 25, color: "#ff6600" },
                { name: "Short Break", duration: 5, color: "#33cc33" },
                { name: "Deep Work Session 2", duration: 25, color: "#ff6600" },
                { name: "Short Break", duration: 5, color: "#33cc33" },
                { name: "Deep Work Session 3", duration: 25, color: "#ff6600" },
                { name: "Long Break", duration: 15, color: "#33cccc" }
            ]
        },
        "Work Sprint": {
            icon: "üíº",
            description: "Professional productivity",
            activities: [
                { name: "Check Email", duration: 10, color: "#3366ff" },
                { name: "Priority Task 1", duration: 30, color: "#ff6600" },
                { name: "Break", duration: 5, color: "#33cc33" },
                { name: "Priority Task 2", duration: 30, color: "#9933cc" }
            ]
        },
        "Evening Wind-Down": {
            icon: "üåô",
            description: "Calm bedtime routine",
            activities: [
                { name: "Tidy Room", duration: 10, color: "#9933cc" },
                { name: "Shower/Bath", duration: 15, color: "#33cccc" },
                { name: "Brush Teeth", duration: 5, color: "#3366ff" },
                { name: "Reading/Calm Activity", duration: 15, color: "#cc3366" }
            ]
        },
        "Quick 10-Min Focus": {
            icon: "‚ö°",
            description: "Beat procrastination fast",
            activities: [
                { name: "Just Start!", duration: 10, color: "#ff6600" }
            ]
        },
        "Exercise Routine": {
            icon: "üí™",
            description: "Active movement session",
            activities: [
                { name: "Warm-Up", duration: 5, color: "#33cc33" },
                { name: "Cardio", duration: 15, color: "#ff6600" },
                { name: "Strength Training", duration: 15, color: "#9933cc" },
                { name: "Cool Down", duration: 5, color: "#33cccc" }
            ]
        },
        "Creative Work": {
            icon: "üé®",
            description: "Structured creative time",
            activities: [
                { name: "Brainstorm", duration: 10, color: "#9933cc" },
                { name: "Create/Design", duration: 30, color: "#ff6600" },
                { name: "Break", duration: 5, color: "#33cc33" },
                { name: "Refine & Edit", duration: 20, color: "#3366ff" }
            ]
}
    };
    
    // Global variables
    let activities = [];
    let currentActivityIndex = 0;
    let timerInterval;
    let isRunning = false;
    let paused = false;
    let pausedRemaining = 0;
    let canvas, ctx, radius;
    let selectedSound = "chimeSound";
    let colorPalette = [...DEFAULT_COLORS];
    let dragStartIndex;
    let inFocusMode = false;
    let startingAngleOffset = 0;
    let totalElapsedTime = 0;
    let clockAnimationFrame;
    let showRealTimeClock = true;
    let useFixedStartPosition = false;
    let lastDeletedActivity = null;
    
    // Timestamp-based timer tracking (critical for background operation)
    let activityStartTimestamp = null;
    let activityExpectedEndTimestamp = null;

    // GOOGLE FORM INTEGRATION
    function openGoogleFeedbackForm() {
        // Track feedback button click
        if (typeof gtag !== 'undefined') {
            gtag('event', 'feedback_opened', {
                'event_category': 'engagement',
                'event_label': 'google_form'
            });
        }
        
        // Open Google Form in new tab
        window.open(GOOGLE_FORM_URL, '_blank');
        
        // Show a notification
        showNotification("üìù Opening feedback form in new tab. Thank you for your input!");
    }

    document.addEventListener("DOMContentLoaded", () => {
        initializeCanvas();
        setupEventListeners();
        loadSavedSettings();
        populateSoundOptions();
        generateColorPalette();
        startRealTimeClock();
        updateStats();
        
        if (localStorage.getItem("activities")) {
            loadActivities();
        }
        
        // Handle page visibility changes (background/foreground)
        setupVisibilityListener();
    });

    function setupEventListeners() {
        document.getElementById("darkModeToggle").addEventListener("change", toggleDarkMode);
        document.getElementById("realTimeClockToggle").addEventListener("change", toggleRealTimeClock);
        document.getElementById("fixedStartToggle").addEventListener("change", toggleFixedStartPosition);
    }
    
    // Critical fix for mobile background timer issues
    function setupVisibilityListener() {
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden && isRunning) {
                // User returned to the page - force immediate recalculation
                console.log('‚ö° Page visible again - recalculating timer...');
                
                // The timestamp-based system will automatically correct itself
                // but we force an immediate visual update
                if (timerInterval) {
                    const activity = activities[currentActivityIndex];
                    const now = Date.now();
                    const elapsed = Math.floor((now - activityStartTimestamp) / 1000);
                    const remaining = Math.max(0, Math.floor((activityExpectedEndTimestamp - now) / 1000));
                    
                    activity.elapsedTime = elapsed;
                    activity.remainingTime = remaining;
                    
                    updateTimerDisplay(remaining);
                    updateTotalTimeIndicator();
                    
                    const totalDuration = activity.duration * 60;
                    let progress = elapsed / totalDuration;
                    progress = Math.min(progress, 1);
                    
                    updateClockDisplay(progress);
                    
                    console.log(`‚úì Recalculated: ${remaining}s remaining, ${Math.round(progress * 100)}% complete`);
                }
            }
        });
        
        // Also listen for page focus (additional safeguard)
        window.addEventListener('focus', function() {
            if (isRunning) {
                console.log('üéØ Window focused - ensuring timer accuracy');
                // Trigger an immediate update cycle
                setTimeout(() => {
                    if (timerInterval && activityStartTimestamp) {
                        const activity = activities[currentActivityIndex];
                        const now = Date.now();
                        const elapsed = Math.floor((now - activityStartTimestamp) / 1000);
                        const remaining = Math.max(0, Math.floor((activityExpectedEndTimestamp - now) / 1000));
                        
                        activity.elapsedTime = elapsed;
                        activity.remainingTime = remaining;
                        
                        updateTimerDisplay(remaining);
                        const totalDuration = activity.duration * 60;
                        let progress = elapsed / totalDuration;
                        updateClockDisplay(Math.min(progress, 1));
                    }
                }, 50);
            }
        });
    }

    function loadSavedSettings() {
        if (localStorage.getItem("darkMode") === "true") {
            document.getElementById("darkModeToggle").checked = true;
            document.body.classList.add("dark-mode");
        }
        
        if (localStorage.getItem("focusMode") === "true") {
            inFocusMode = true;
            document.body.classList.add("focus-mode");
        }
        
        if (localStorage.getItem("showRealTimeClock") === "false") {
            showRealTimeClock = false;
            document.getElementById("realTimeClockToggle").checked = false;
        }
        
        if (localStorage.getItem("useFixedStartPosition") === "true") {
            useFixedStartPosition = true;
            document.getElementById("fixedStartToggle").checked = true;
        }
        
        if (localStorage.getItem("selectedSound")) {
            selectedSound = localStorage.getItem("selectedSound");
        }
        
        if (localStorage.getItem("colorPalette")) {
            try {
                colorPalette = JSON.parse(localStorage.getItem("colorPalette"));
            } catch (e) {
                colorPalette = [...DEFAULT_COLORS];
            }
        }
    }

    function initializeCanvas() {
        canvas = document.getElementById("analogClock");
        resizeCanvas();
        ctx = canvas.getContext("2d");
        radius = canvas.width / 2;
        ctx.translate(radius, radius);
        window.addEventListener('resize', resizeCanvas);
        updateClockDisplay();
    }

    function resizeCanvas() {
        const container = document.querySelector('.clock-container');
        const isMobile = window.innerWidth <= 600;
        const buffer = isMobile ? 16 : 40;
        const size = Math.min(container.clientWidth - buffer, container.clientHeight - buffer);
        canvas.width = size;
        canvas.height = size;
        if (ctx) {
            radius = canvas.width / 2;
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.translate(radius, radius);
        }
    }

    function toggleDarkMode(e) {
        document.body.classList.toggle("dark-mode", e.target.checked);
        localStorage.setItem("darkMode", e.target.checked);
        updateClockDisplay();
    }
    
    function toggleFocusMode() {
        inFocusMode = !inFocusMode;
        document.body.classList.toggle("focus-mode", inFocusMode);
        localStorage.setItem("focusMode", inFocusMode);
        updateNextActivityIndicator();
        
        setTimeout(() => {
            resizeCanvas();
            updateClockDisplay();
        }, 300);
    }

    function toggleRealTimeClock() {
        showRealTimeClock = !showRealTimeClock;
        localStorage.setItem("showRealTimeClock", showRealTimeClock);
        updateClockDisplay();
        document.getElementById("realTimeClockToggle").checked = showRealTimeClock;
    }

    function toggleFixedStartPosition() {
        useFixedStartPosition = document.getElementById("fixedStartToggle").checked;
        localStorage.setItem("useFixedStartPosition", useFixedStartPosition);
        updateClockDisplay();
        
        if (isRunning) {
            const activity = activities[currentActivityIndex];
            const progress = (activity.duration * 60 - activity.remainingTime) / (activity.duration * 60);
            updateClockDisplay(progress);
        }
    }
    
    function updateNextActivityIndicator() {
        const nextActivityContainer = document.getElementById("nextActivityContainer");
        
        if (isRunning && inFocusMode && currentActivityIndex < activities.length - 1) {
            const nextActivity = activities[currentActivityIndex + 1];
            document.getElementById("nextActivityLabel").innerText = `${nextActivity.name} (${nextActivity.duration}m)`;
            document.getElementById("nextActivityLabel").style.backgroundColor = nextActivity.color;
            nextActivityContainer.style.display = "inline-block";
        } else {
            nextActivityContainer.style.display = "none";
        }
    }

    function drawClockBase() {
        ctx.beginPath();
        ctx.arc(0, 0, radius - 10, 0, 2 * Math.PI);
        ctx.fillStyle = document.body.classList.contains("dark-mode") ? "#333" : "white";
        ctx.fill();
        ctx.lineWidth = 3;
        ctx.strokeStyle = document.body.classList.contains("dark-mode") ? "#4facfe" : "#667eea";
        ctx.stroke();
    }

    function drawClockNumbers() {
        ctx.font = radius * 0.12 + "px 'Segoe UI', sans-serif";
        ctx.fillStyle = document.body.classList.contains("dark-mode") ? "white" : "#333";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fontWeight = "600";
        
        for (let i = 1; i <= 12; i++) {
            let angle = (i * 30) * (Math.PI / 180);
            let x = Math.cos(angle - Math.PI / 2) * (radius - 35);
            let y = Math.sin(angle - Math.PI / 2) * (radius - 35);
            ctx.fillText(i, x, y);
        }
    }

    function drawMinuteHashes() {
        ctx.strokeStyle = document.body.classList.contains("dark-mode") ? "#4facfe" : "#667eea";
        ctx.lineWidth = 1;
        
        for (let i = 0; i < 60; i++) {
            let angle = i * 6 * (Math.PI / 180);
            let isHour = i % 5 === 0;
            let innerRadius = radius - (isHour ? 25 : 15);
            let outerRadius = radius - 10;
            
            let x1 = Math.cos(angle - Math.PI / 2) * innerRadius;
            let y1 = Math.sin(angle - Math.PI / 2) * innerRadius;
            let x2 = Math.cos(angle - Math.PI / 2) * outerRadius;
            let y2 = Math.sin(angle - Math.PI / 2) * outerRadius;
            
            ctx.lineWidth = isHour ? 2 : 1;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }
    }
    
    function drawRealTimeClock() {
        const now = new Date();
        const hours = now.getHours() % 12;
        const minutes = now.getMinutes();
        const seconds = now.getSeconds();
        const milliseconds = now.getMilliseconds();
        
        const smoothMinutes = minutes + (seconds / 60) + (milliseconds / 60000);
        const smoothHours = hours + (smoothMinutes / 60);
        
        // Hour hand
        ctx.strokeStyle = document.body.classList.contains("dark-mode") ? "#fff" : "#333";
        ctx.lineWidth = 6;
        ctx.lineCap = "round";
        ctx.beginPath();
        const hourAngle = smoothHours * 30 * (Math.PI / 180);
        ctx.moveTo(0, 0);
        ctx.lineTo(
            Math.cos(hourAngle - Math.PI / 2) * (radius * 0.5),
            Math.sin(hourAngle - Math.PI / 2) * (radius * 0.5)
        );
        ctx.stroke();
        
        // Minute hand
        ctx.lineWidth = 4;
        ctx.beginPath();
        const minuteAngle = smoothMinutes * 6 * (Math.PI / 180);
        ctx.moveTo(0, 0);
        ctx.lineTo(
            Math.cos(minuteAngle - Math.PI / 2) * (radius * 0.7),
            Math.sin(minuteAngle - Math.PI / 2) * (radius * 0.7)
        );
        ctx.stroke();
        
        // Second hand
        ctx.strokeStyle = "#ff4757";
        ctx.lineWidth = 2;
        ctx.beginPath();
        const secondAngle = seconds * 6 * (Math.PI / 180);
        ctx.moveTo(0, 0);
        ctx.lineTo(
            Math.cos(secondAngle - Math.PI / 2) * (radius * 0.8),
            Math.sin(secondAngle - Math.PI / 2) * (radius * 0.8)
        );
        ctx.stroke();
        
        // Center circle
        ctx.fillStyle = "#ff4757";
        ctx.beginPath();
        ctx.arc(0, 0, radius * 0.05, 0, 2 * Math.PI);
        ctx.fill();
    }

    function drawActivitySectors(currentProgress = 0) {
        if (activities.length === 0) return;
        
        let startAngle = -Math.PI / 2;
        
        if (!useFixedStartPosition && isRunning) {
            startAngle += startingAngleOffset;
        }
        
        activities.forEach((activity, index) => {
            let arcLength = (activity.duration / 60) * 2 * Math.PI;
            let endAngle = startAngle + arcLength;

            if (index === currentActivityIndex && isRunning) {
                // Draw completed portion of current activity (darker)
                let progressAngle = startAngle + arcLength * currentProgress;
                
                if (currentProgress > 0) {
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, radius - 20, startAngle, progressAngle);
                    ctx.closePath();
                    ctx.fillStyle = activity.color;
                    ctx.globalAlpha = 0.4;
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    
                    // Border for completed portion
                    ctx.strokeStyle = "rgba(255,255,255,0.3)";
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
                
                // Draw remaining portion of current activity (bright)
                if (currentProgress < 1) {
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, radius - 20, progressAngle, endAngle);
                    ctx.closePath();
                    ctx.fillStyle = activity.color;
                    ctx.globalAlpha = 0.9;
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    
                    // Border for remaining portion
                    ctx.strokeStyle = "rgba(255,255,255,0.3)";
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            } else {
                // Draw completed or future activities
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.arc(0, 0, radius - 20, startAngle, endAngle);
                ctx.closePath();
                ctx.fillStyle = activity.color;
                ctx.globalAlpha = activity.completed ? 0.3 : 0.6;
                ctx.fill();
                ctx.globalAlpha = 1;
                
                // Add a subtle border
                ctx.strokeStyle = "rgba(255,255,255,0.3)";
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
            startAngle = endAngle;
        });
    }

    function updateClockDisplay(currentProgress = 0) {
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.translate(radius, radius);
        
        drawClockBase();
        drawMinuteHashes();
        drawClockNumbers();
        drawActivitySectors(currentProgress);
        
        if (showRealTimeClock) {
            drawRealTimeClock();
        }
    }
    
    function startRealTimeClock() {
        if (clockAnimationFrame) cancelAnimationFrame(clockAnimationFrame);
        
        function animateClock() {
            if (!isRunning && showRealTimeClock) {
                updateClockDisplay();
                clockAnimationFrame = requestAnimationFrame(animateClock);
            }
        }
        animateClock();
    }

    function playSound(soundId = selectedSound) {
        try {
            const soundElement = document.getElementById(soundId);
            if (soundElement) {
                soundElement.currentTime = 0;
                soundElement.play().catch(error => {
                    console.warn("Could not play sound:", error);
                });
                
                setTimeout(() => {
                    if (!soundElement.paused) {
                        soundElement.pause();
                        soundElement.currentTime = 0;
                    }
                }, 5000);
            }
        } catch (error) {
            console.error("Error playing sound:", error);
        }
    }

    function addActivity() {
        let name = prompt("Enter activity name:");
        if (!name || name.trim() === "") return;

        let durationInput = prompt("Enter duration (minutes):");
        let duration = parseInt(durationInput);
        
        if (isNaN(duration) || duration <= 0) {
            showNotification("‚ùå Please enter a valid positive number for duration.");
            return;
        }

        let color = colorPalette[activities.length % colorPalette.length];
        activities.push({ 
            name, 
            duration, 
            color, 
            completed: false,
            startTime: null,
            elapsedTime: 0,
            remainingTime: duration * 60
        });
        
        updateClockDisplay();
        updateActivityKey();
        updateStats();
        showNotification(`‚úÖ Activity "${name}" added successfully!`);
    }

    function updateStats() {
        document.getElementById("totalActivities").textContent = activities.length;
        document.getElementById("completedCount").textContent = activities.filter(a => a.completed).length;
        
        const totalMinutes = activities.reduce((sum, act) => sum + act.duration, 0);
        document.getElementById("totalPlannedTime").textContent = totalMinutes + "m";
        
        const completedCount = activities.filter(a => a.completed).length;
        const progressPercent = activities.length > 0 ? 
            Math.round((completedCount / activities.length) * 100) : 0;
        document.getElementById("progressStat").textContent = progressPercent + "%";
    }

    function updateActivityKey() {
        let keyContainer = document.getElementById("activityKey");
        
        if (activities.length === 0) {
            keyContainer.innerHTML = `
                <h3>Activity Timeline</h3>
                <p style="text-align: center; color: #666; margin-bottom: 20px;">Add activities to see your personalized schedule</p>
            `;
            return;
        }
        
        keyContainer.innerHTML = `
            <h3>Activity Timeline</h3>
            <p style="text-align: center; color: #666; margin-bottom: 20px;"><small>Drag rows to reorder activities</small></p>
        `;
        
        let table = document.createElement("table");
        table.id = "activitiesTable";
        let headerRow = table.insertRow();
        headerRow.innerHTML = "<th></th><th>Color</th><th>Activity</th><th>Time (min)</th><th>Start Time</th><th>Status</th><th>Actions</th>";
        
        activities.forEach((act, i) => {
            let row = table.insertRow();
            row.classList.add("draggable-row");
            row.setAttribute("data-index", i);
            
            let dragCell = row.insertCell();
            let colorCell = row.insertCell();
            let nameCell = row.insertCell();
            let durationCell = row.insertCell();
            let startTimeCell = row.insertCell();
            let statusCell = row.insertCell();
            let actionsCell = row.insertCell();
            
            dragCell.classList.add("drag-handle");
            
            colorCell.innerHTML = `<span class='color-box' style='background:${act.color}' onclick='openColorPickerForActivity(${i})'></span>`;
            nameCell.setAttribute('contenteditable', 'true');
            nameCell.innerText = act.name;
            nameCell.addEventListener('blur', () => validateAndUpdateActivity(i, 'name', nameCell.innerText));
            
            durationCell.setAttribute('contenteditable', 'true');
            durationCell.innerText = act.duration;
            durationCell.addEventListener('blur', () => validateAndUpdateActivity(i, 'duration', durationCell.innerText));
            
            startTimeCell.id = `activity-start-time-${i}`;
            startTimeCell.innerText = act.startTime ? formatTime(act.startTime) : calculateProjectedStartTime(i);
            
            statusCell.id = `activity-status-${i}`;
            statusCell.innerText = act.completed ? "‚úî Completed" : "Pending";
            
            const deleteBtn = document.createElement('button');
            deleteBtn.innerText = 'Delete';
            deleteBtn.className = 'btn-danger';
            deleteBtn.style.padding = '5px 10px';
            deleteBtn.style.fontSize = '0.8rem';
            deleteBtn.onclick = () => deleteActivity(i);
            actionsCell.appendChild(deleteBtn);
        });
        
        keyContainer.appendChild(table);
        setupDragAndDrop();
    }

    function formatTime(date) {
        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }
    
    function calculateProjectedStartTime(activityIndex) {
        if (isRunning && activities[activityIndex].startTime) {
            return formatTime(activities[activityIndex].startTime);
        }
        
        const now = new Date();
        let projectedStart = new Date(now);
        
        for (let i = 0; i < activityIndex; i++) {
            projectedStart = new Date(projectedStart.getTime() + activities[i].duration * 60000);
        }
        
        return formatTime(projectedStart);
    }
    
    function validateAndUpdateActivity(index, field, value) {
        if (index >= activities.length) return;
        
        if (field === 'name') {
            if (value.trim() === '') {
                showNotification('‚ùå Activity name cannot be empty');
                updateActivityKey();
                return;
            }
            activities[index].name = value.trim();
        } 
        else if (field === 'duration') {
            const duration = parseInt(value);
            if (isNaN(duration) || duration <= 0) {
                showNotification('‚ùå Duration must be a positive number');
                updateActivityKey();
                return;
            }
            activities[index].duration = duration;
            if (!activities[index].startTime || activities[index].completed) {
                activities[index].remainingTime = duration * 60;
            }
        }
        
        updateClockDisplay();
        updateNextActivityIndicator();
        updateStats();
    }
    
    function deleteActivity(index) {
        if (isRunning) {
            showNotification("‚è∏Ô∏è Please stop the timer before deleting activities.");
            return;
        }
        
        lastDeletedActivity = { ...activities[index], index };
        activities.splice(index, 1);
        updateActivityKey();
        updateClockDisplay();
        updateStats();
        
        const undoBanner = document.getElementById("undoBanner");
        undoBanner.style.display = "block";
        clearTimeout(undoBanner.hideTimer);
        undoBanner.hideTimer = setTimeout(() => {
            undoBanner.style.display = "none";
            lastDeletedActivity = null;
        }, 5000);
        
        if (currentActivityIndex >= index) {
            currentActivityIndex = Math.max(0, currentActivityIndex - 1);
        }
    }

    function undoDelete() {
        if (!lastDeletedActivity) return;
        activities.splice(lastDeletedActivity.index, 0, lastDeletedActivity);
        updateActivityKey();
        updateClockDisplay();
        updateStats();
        lastDeletedActivity = null;
        document.getElementById("undoBanner").style.display = "none";
    }

    function startTimer() {
        if (isRunning) return;
        if (activities.length === 0) {
            showNotification("‚ùå Please add at least one activity first.");
            return;
        }
        
        isRunning = true;
        document.body.classList.add('timer-running');
        document.getElementById("resumeBtn").style.display = "none";
        document.getElementById("pauseBtn").style.display = "inline-block";
        document.getElementById("skipBtn").style.display = "inline-block";
        document.getElementById("startBtn").style.display = "none";
        
        if (!useFixedStartPosition) {
            const now = new Date();
            const minutes = now.getMinutes();
            const seconds = now.getSeconds();
            startingAngleOffset = ((minutes * 60 + seconds) / 3600) * (2 * Math.PI);
        } else {
            startingAngleOffset = 0;
        }
        
        totalElapsedTime = 0;
        
        let currentStartTime = new Date();
        activities.forEach((activity, index) => {
            activity.startTime = new Date(currentStartTime);
            activity.completed = index < currentActivityIndex;
            activity.elapsedTime = 0;
            activity.remainingTime = activity.duration * 60;
            currentStartTime = new Date(currentStartTime.getTime() + activity.duration * 60000);
        });
        
        updateActivityKey();
        updateTotalTimeIndicator();
        
        if (!inFocusMode) {
            toggleFocusMode();
        }
        
        runActivity(currentActivityIndex);
        showNotification("üöÄ Timer started! Stay focused!");
    }

    function updateTotalTimeIndicator() {
        const totalTimeContainer = document.getElementById("totalTimeContainer");
        const endTimeContainer = document.getElementById("endTimeContainer");
        const progressContainer = document.querySelector('.progress-container');
        
        if (!totalTimeContainer || !endTimeContainer) return;

        const now = new Date();
        let totalSeconds = activities.reduce((sum, act, idx) => {
            if (idx < currentActivityIndex) return sum;
            return sum + (act.remainingTime || act.duration * 60);
        }, 0);

        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;

        totalTimeContainer.innerText = `‚è∞ Time Remaining: ${hours > 0 ? hours + 'h ' : ''}${minutes}m ${seconds}s`;

        const estimatedEnd = new Date(now.getTime() + totalSeconds * 1000);
        endTimeContainer.innerText = `üéØ Estimated End: ${estimatedEnd.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;

        const progressBar = document.getElementById("overallProgressBar");
        const totalPlanned = activities.reduce((sum, act) => sum + act.duration * 60, 0);
        const completedSeconds = totalPlanned - totalSeconds;
        const percentage = Math.min(100, Math.floor((completedSeconds / totalPlanned) * 100));
        progressBar.style.width = percentage + "%";

        totalTimeContainer.style.display = isRunning ? 'block' : 'none';
        endTimeContainer.style.display = isRunning ? 'block' : 'none';
        progressContainer.style.display = isRunning ? 'block' : 'none';
    }
    
    function skipToNext() {
        if (!isRunning) return;
        
        clearInterval(timerInterval);
        playSound("beepSound");
        
        const currentActivity = activities[currentActivityIndex];
        currentActivity.completed = true;
        updateActivityStatus(currentActivityIndex);
        
        const now = new Date();
        currentActivityIndex++;
        
        if (currentActivityIndex < activities.length) {
            const nextActivity = activities[currentActivityIndex];
            nextActivity.startTime = new Date(now);
            
            for (let i = currentActivityIndex + 1; i < activities.length; i++) {
                const prevActivityEndTime = i === currentActivityIndex + 1 
                    ? new Date(nextActivity.startTime.getTime() + (nextActivity.duration * 60000))
                    : new Date(activities[i-1].startTime.getTime() + (activities[i-1].duration * 60000));
                
                activities[i].startTime = prevActivityEndTime;
            }
            
            updateActivityKey();
            updateClockDisplay();
            updateNextActivityIndicator();
            updateStats();
            
            runActivity(currentActivityIndex);
            showNotification(`‚è≠Ô∏è Skipped to: ${nextActivity.name}`);
        } else {
            endSession();
        }
    }

    // Lock Screen Integration Variables
    let silentAudio = null;
    let mediaSessionActive = false;

    // Initialize silent audio for lock screen (required for Media Session API)
    function initializeLockScreenAudio() {
        if (!silentAudio) {
            silentAudio = new Audio();
            // Create a silent audio data URL (1 second of silence)
            const silentData = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=';
            silentAudio.src = silentData;
            silentAudio.loop = true;
            silentAudio.volume = 0.01; // Nearly silent
        }
    }

    // Update Media Session for lock screen display
    function updateMediaSession(activityName, remainingSeconds, totalSeconds, currentIndex, totalActivities) {
        if (!('mediaSession' in navigator)) {
            console.log('‚ö†Ô∏è Media Session API not supported on this device');
            return;
        }

        try {
            // Start silent audio if not playing (required for lock screen on iOS)
            if (silentAudio && silentAudio.paused) {
                silentAudio.play().catch(err => console.log('Silent audio play failed:', err));
            }

            const minutes = Math.floor(remainingSeconds / 60);
            const seconds = remainingSeconds % 60;
            const timeDisplay = `${minutes}:${seconds.toString().padStart(2, '0')}`;

            // Set metadata that appears on lock screen
            navigator.mediaSession.metadata = new MediaMetadata({
                title: `‚è∞ ${activityName}`,
                artist: `Time Remaining: ${timeDisplay}`,
                album: `Activity ${currentIndex + 1} of ${totalActivities}`,
                artwork: [
                    {
                        src: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200"><circle cx="100" cy="100" r="80" fill="%234facfe"/><text x="100" y="120" font-size="60" text-anchor="middle" fill="white">' + minutes + '</text></svg>',
                        sizes: '200x200',
                        type: 'image/svg+xml'
                    }
                ]
            });

            // Set playback state
            navigator.mediaSession.playbackState = 'playing';

            // Set position state (shows progress bar on lock screen)
            if ('setPositionState' in navigator.mediaSession) {
                const elapsed = totalSeconds - remainingSeconds;
                navigator.mediaSession.setPositionState({
                    duration: totalSeconds,
                    playbackRate: 1.0,
                    position: elapsed
                });
            }

            // Handle lock screen controls
            navigator.mediaSession.setActionHandler('play', () => {
                if (paused) resumeTimer();
            });

            navigator.mediaSession.setActionHandler('pause', () => {
                if (isRunning) pauseTimer();
            });

            navigator.mediaSession.setActionHandler('nexttrack', () => {
                if (isRunning) skipToNext();
            });

            navigator.mediaSession.setActionHandler('previoustrack', () => {
                // Could add "restart current activity" functionality
            });

            mediaSessionActive = true;

        } catch (error) {
            console.error('Media Session error:', error);
        }
    }

    // Clear Media Session when timer stops
    function clearMediaSession() {
        if ('mediaSession' in navigator) {
            navigator.mediaSession.playbackState = 'none';
            navigator.mediaSession.metadata = null;
        }
        if (silentAudio && !silentAudio.paused) {
            silentAudio.pause();
        }
        mediaSessionActive = false;
    }

    // Timestamp-based timer implementation
    function runActivity(index) {
        if (index >= activities.length) {
            endSession();
            return;
        }
        
        currentActivityIndex = index;
        let activity = activities[index];
        
        // Use timestamp-based tracking instead of setInterval counting
        if (paused) {
            // When resuming from pause, calculate new end time based on remaining seconds
            activityStartTimestamp = Date.now();
            activityExpectedEndTimestamp = Date.now() + (pausedRemaining * 1000);
            paused = false;
        } else {
            // Fresh activity start
            activityStartTimestamp = Date.now();
            activityExpectedEndTimestamp = Date.now() + (activity.remainingTime * 1000);
        }

        document.getElementById("activityLabel").innerText = `Current: ${activity.name}`;
        document.getElementById("activityLabel").style.background = `linear-gradient(45deg, ${activity.color}, ${adjustBrightness(activity.color, 20)})`;

        updateNextActivityIndicator();
        
        // Initialize lock screen integration
        initializeLockScreenAudio();
        
        clearInterval(timerInterval);
        
        // Main timer loop - now calculates remaining time from timestamps
        timerInterval = setInterval(() => {
            const now = Date.now();
            const elapsed = Math.floor((now - activityStartTimestamp) / 1000);
            const remaining = Math.max(0, Math.floor((activityExpectedEndTimestamp - now) / 1000));
            
            // Update activity tracking
            activity.elapsedTime = elapsed;
            activity.remainingTime = remaining;
            
            // Update lock screen display (every second)
            updateMediaSession(
                activity.name,
                remaining,
                activity.duration * 60,
                currentActivityIndex,
                activities.length
            );
            
            if (remaining <= 0) {
                clearInterval(timerInterval);
                playSound();
                activities[index].completed = true;
                updateActivityStatus(index);
                updateClockDisplay();
                updateStats();
                document.getElementById("digitalTimer").innerText = "";
                
                showNotification(`‚úÖ "${activity.name}" completed!`);
                
                if (index + 1 < activities.length) {
                    const now = new Date();
                    activities[index + 1].startTime = now;
                    
                    for (let i = index + 2; i < activities.length; i++) {
                        const prevEnd = new Date(activities[i-1].startTime.getTime() + 
                                                (activities[i-1].duration * 60000));
                        activities[i].startTime = prevEnd;
                    }
                    
                    updateActivityKey();
                }
                
                setTimeout(() => runActivity(index + 1), 1000);
                return;
            }
            
            updateTimerDisplay(remaining);
            updateTotalTimeIndicator();
            
            // Calculate progress based on actual elapsed time vs total duration
            const totalDuration = activity.duration * 60;
            let progress = elapsed / totalDuration;
            progress = Math.min(progress, 1); // Cap at 100%
            
            updateClockDisplay(progress);
        }, 100); // Update every 100ms for smooth progress, but calculate from timestamps
    }

    function endSession() {
        isRunning = false;
        document.body.classList.remove('timer-running');
        document.getElementById("activityLabel").innerText = "üéâ All Activities Completed!";
        document.getElementById("activityLabel").style.background = "linear-gradient(45deg, #4caf50, #66bb6a)";
        document.getElementById("digitalTimer").innerText = "";
        document.getElementById("pauseBtn").style.display = "none";
        document.getElementById("skipBtn").style.display = "none";
        document.getElementById("startBtn").style.display = "inline-block";
        
        document.getElementById("nextActivityContainer").style.display = "none";
        document.getElementById("totalTimeContainer").style.display = "none";
        document.getElementById("endTimeContainer").style.display = "none";
        document.querySelector('.progress-container').style.display = "none";
        
        // Clear lock screen display
        clearMediaSession();
        
        updateStats();
        playSound();
        showNotification("üéâ Congratulations! All activities completed!");
        
        setTimeout(() => {
            showSummary();
        }, 2000);
    }
    
    function updateTimerDisplay(seconds) {
        let minutes = Math.floor(seconds / 60).toString().padStart(2, '0');
        let remainingSeconds = (seconds % 60).toString().padStart(2, '0');
        document.getElementById("digitalTimer").innerText = `${minutes}:${remainingSeconds}`;
    }
    
    function updateActivityStatus(index) {
        const statusElement = document.getElementById(`activity-status-${index}`);
        if (statusElement) {
            statusElement.innerText = "‚úî Completed";
            statusElement.style.color = "#4caf50";
            statusElement.style.fontWeight = "bold";
        }
    }

    function pauseTimer() {
        if (!isRunning) return;
        
        clearInterval(timerInterval);
        paused = true;
        isRunning = false;
        
        // Calculate remaining time from timestamp (more accurate)
        if (activityExpectedEndTimestamp) {
            const now = Date.now();
            pausedRemaining = Math.max(0, Math.floor((activityExpectedEndTimestamp - now) / 1000));
        } else {
            pausedRemaining = activities[currentActivityIndex].remainingTime;
        }
        
        // Pause lock screen display
        if ('mediaSession' in navigator) {
            navigator.mediaSession.playbackState = 'paused';
        }
        
        document.getElementById("resumeBtn").style.display = "inline-block";
        document.getElementById("pauseBtn").style.display = "none";
        
        showNotification("‚è∏Ô∏è Timer paused");
    }

    function resumeTimer() {
        if (!paused) return;
        
        const now = new Date();
        const currentActivity = activities[currentActivityIndex];
        
        for (let i = currentActivityIndex; i < activities.length; i++) {
            if (i === currentActivityIndex) {
                const timeElapsed = currentActivity.duration * 60 - pausedRemaining;
                currentActivity.startTime = new Date(now.getTime() - (timeElapsed * 1000));
            } else {
                const prevActivity = activities[i-1];
                const prevEndTime = new Date(prevActivity.startTime.getTime() + 
                                          (prevActivity.remainingTime * 1000));
                activities[i].startTime = prevEndTime;
            }
        }
        
        isRunning = true;
        document.getElementById("resumeBtn").style.display = "none";
        document.getElementById("pauseBtn").style.display = "inline-block";
        updateActivityKey();
        runActivity(currentActivityIndex);
        
        showNotification("‚ñ∂Ô∏è Timer resumed");
    }

    function resetTimer() {
        clearInterval(timerInterval);
        isRunning = false;
        document.body.classList.remove('timer-running');
        paused = false;
        startingAngleOffset = 0;
        totalElapsedTime = 0;
        
        // Clear lock screen display
        clearMediaSession();
        
        if (confirm("Reset all activities? This will clear your activity list.")) {
            activities = [];
            currentActivityIndex = 0;
            document.getElementById("activityLabel").innerText = "No Activities Started";
            document.getElementById("activityLabel").style.background = "linear-gradient(45deg, #ffd700, #ffed4e)";
            document.getElementById("digitalTimer").innerText = "";
            document.getElementById("resumeBtn").style.display = "none";
            document.getElementById("pauseBtn").style.display = "inline-block";
            document.getElementById("skipBtn").style.display = "none";
            document.getElementById("startBtn").style.display = "inline-block";
            updateClockDisplay();
            updateActivityKey();
            updateStats();
            
            document.getElementById("nextActivityContainer").style.display = "none";
            document.getElementById("totalTimeContainer").style.display = "none";
            document.getElementById("endTimeContainer").style.display = "none";
            document.querySelector('.progress-container').style.display = "none";
            
            showNotification("üîÑ Activities cleared");
        } else {
            activities.forEach(act => {
                act.completed = false;
                act.startTime = null;
                act.elapsedTime = 0;
                act.remainingTime = act.duration * 60;
            });
            currentActivityIndex = 0;
            document.getElementById("activityLabel").innerText = "Timer Reset";
            document.getElementById("activityLabel").style.background = "linear-gradient(45deg, #ffd700, #ffed4e)";
            document.getElementById("digitalTimer").innerText = "";
            document.getElementById("resumeBtn").style.display = "none";
            document.getElementById("pauseBtn").style.display = "inline-block";
            document.getElementById("skipBtn").style.display = "none";
            document.getElementById("startBtn").style.display = "inline-block";
            updateActivityKey();
            updateClockDisplay();
            updateStats();
            
            document.getElementById("nextActivityContainer").style.display = "none";
            document.getElementById("totalTimeContainer").style.display = "none";
            document.getElementById("endTimeContainer").style.display = "none";
            document.querySelector('.progress-container').style.display = "none";
            
            showNotification("üîÑ Timer reset");
        }
        
        if (inFocusMode) {
            toggleFocusMode();
        }
    }

    function saveActivities() {
        try {
            localStorage.setItem("activities", JSON.stringify(activities));
        } catch (error) {
            console.error("Error saving activities:", error);
            showNotification("‚ùå Could not save activities");
        }
    }

    function loadActivities() {
        try {
            const saved = localStorage.getItem("activities");
            if (saved) {
                activities = JSON.parse(saved);
                activities.forEach(act => {
                    if (act.startTime) {
                        act.startTime = new Date(act.startTime);
                    }
                    act.completed = false;
                    if (typeof act.remainingTime === 'undefined') {
                        act.remainingTime = act.duration * 60;
                    }
                    if (typeof act.elapsedTime === 'undefined') {
                        act.elapsedTime = 0;
                    }
                });
                updateActivityKey();
                updateClockDisplay();
                updateStats();
                showNotification("üìÇ Activities loaded!");
            } else {
                showNotification("‚ùå No saved activities found");
            }
        } catch (error) {
            console.error("Error loading activities:", error);
            showNotification("‚ùå Could not load activities");
        }
    }

    // Utility Functions
    function adjustBrightness(color, percent) {
        const num = parseInt(color.replace("#",""), 16);
        const amt = Math.round(2.55 * percent);
        const R = (num >> 16) + amt;
        const G = (num >> 8 & 0x00FF) + amt;
        const B = (num & 0x0000FF) + amt;
        return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 +
            (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255))
            .toString(16).slice(1);
    }

    function showNotification(message) {
        const notification = document.getElementById("notification");
        notification.textContent = message;
        notification.classList.add("show");
        
        setTimeout(() => {
            notification.classList.remove("show");
        }, 3000);
    }

    // Drag and Drop functionality
    function setupDragAndDrop() {
        const table = document.getElementById("activitiesTable");
        if (!table) return;
        
        const rows = table.querySelectorAll('.draggable-row');
        
        rows.forEach(row => {
            const dragHandle = row.querySelector('.drag-handle');
            
            dragHandle.addEventListener('mousedown', function(e) {
                e.preventDefault();
                dragStartIndex = parseInt(row.getAttribute('data-index'));
                row.classList.add('dragging');
                document.addEventListener('mousemove', handleDrag);
                document.addEventListener('mouseup', stopDrag);
            });
            
            dragHandle.addEventListener('touchstart', function(e) {
                dragStartIndex = parseInt(row.getAttribute('data-index'));
                row.classList.add('dragging');
                document.addEventListener('touchmove', handleTouchDrag);
                document.addEventListener('touchend', stopDrag);
            });
        });
    }

    function handleDrag(e) {
        const draggingRow = document.querySelector('.dragging');
        if (!draggingRow) return;
        
        const table = document.getElementById("activitiesTable");
        const rows = Array.from(table.querySelectorAll('.draggable-row'));
        
        let closest = null;
        let closestDistance = Infinity;
        
        rows.forEach(row => {
            if (row === draggingRow) return;
            
            const rect = row.getBoundingClientRect();
            const rowMiddle = rect.top + rect.height / 2;
            const distance = Math.abs(e.clientY - rowMiddle);
            
            if (distance < closestDistance) {
                closest = row;
                closestDistance = distance;
            }
        });
        
        if (closest) {
            const rect = closest.getBoundingClientRect();
            const rowMiddle = rect.top + rect.height / 2;
            
            if (e.clientY < rowMiddle) {
                table.insertBefore(draggingRow, closest);
            } else {
                table.insertBefore(draggingRow, closest.nextSibling);
            }
            
            updateRowIndices();
        }
    }
    
    function handleTouchDrag(e) {
        const touch = e.touches[0];
        const mouseEvent = {
            clientX: touch.clientX,
            clientY: touch.clientY
        };
        handleDrag(mouseEvent);
    }
    
    function stopDrag() {
        const draggingRow = document.querySelector('.dragging');
        if (!draggingRow) return;
        
        draggingRow.classList.remove('dragging');
        const dragEndIndex = parseInt(draggingRow.getAttribute('data-index'));
        
        if (dragStartIndex !== dragEndIndex) {
            const [movedActivity] = activities.splice(dragStartIndex, 1);
            activities.splice(dragEndIndex, 0, movedActivity);
            
            updateActivityKey();
            updateClockDisplay();
            
            if (isRunning) {
                if (currentActivityIndex === dragStartIndex) {
                    currentActivityIndex = dragEndIndex;
                } else if (dragStartIndex < currentActivityIndex && currentActivityIndex <= dragEndIndex) {
                    currentActivityIndex--;
                } else if (dragStartIndex > currentActivityIndex && currentActivityIndex >= dragEndIndex) {
                    currentActivityIndex++;
                }
            }
            
            updateNextActivityIndicator();
            showNotification("üìã Activities reordered");
        }
        
        document.removeEventListener('mousemove', handleDrag);
        document.removeEventListener('mouseup', stopDrag);
        document.removeEventListener('touchmove', handleTouchDrag);
        document.removeEventListener('touchend', stopDrag);
    }
    
    function updateRowIndices() {
        const table = document.getElementById("activitiesTable");
        const rows = Array.from(table.querySelectorAll('.draggable-row'));
        
        rows.forEach((row, index) => {
            row.setAttribute('data-index', index);
        });
    }
    
    // Color Management Functions
    function openColorModal() {
        document.getElementById('colorModal').style.display = 'block';
    }
    
    function closeModal(modalId) {
        document.getElementById(modalId).style.display = 'none';
    }
    
    function generateColorPalette() {
        const baseColor = document.getElementById('baseColor').value;
        const harmonyType = document.getElementById('harmonyType').value;
        
        const palette = generateHarmony(baseColor, harmonyType);
        colorPalette = palette;
        
        localStorage.setItem('colorPalette', JSON.stringify(colorPalette));
        displayColorPalette(palette);
        
        if (activities.length > 0) {
            activities.forEach((activity, index) => {
                activity.color = palette[index % palette.length];
            });
            updateActivityKey();
            updateClockDisplay();
        }
    }
    
    function displayColorPalette(palette) {
        const container = document.getElementById('colorPalette');
        container.innerHTML = '';
        
        palette.forEach((color, index) => {
            const colorDiv = document.createElement('div');
            colorDiv.className = 'color-option';
            colorDiv.style.backgroundColor = color;
            colorDiv.title = color;
            colorDiv.setAttribute('data-color', color);
            
            colorDiv.addEventListener('click', () => {
                selectColor(colorDiv);
            });
            
            container.appendChild(colorDiv);
        });
    }
    
    function selectColor(element) {
        document.querySelectorAll('.color-option').forEach(el => {
            el.classList.remove('selected');
        });
        element.classList.add('selected');
    }
    
    function openColorPickerForActivity(activityIndex) {
        window.currentEditingActivity = activityIndex;
        openColorModal();
        
        document.querySelectorAll('.color-option').forEach(option => {
            option.addEventListener('click', function() {
                const color = this.getAttribute('data-color');
                updateActivityColor(window.currentEditingActivity, color);
                closeModal('colorModal');
            }, { once: true });
        });
    }
    
    function updateActivityColor(index, color) {
        if (index >= 0 && index < activities.length) {
            activities[index].color = color;
            updateActivityKey();
            updateClockDisplay();
            showNotification("üé® Activity color updated!");
        }
    }
    
    // Color Harmony Generation
    function hexToRgb(hex) {
        hex = hex.replace('#', '');
        const r = parseInt(hex.substring(0, 2), 16);
        const g = parseInt(hex.substring(2, 4), 16);
        const b = parseInt(hex.substring(4, 6), 16);
        return { r, g, b };
    }
    
    function rgbToHsl(r, g, b) {
        r /= 255; g /= 255; b /= 255;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        
        if (max === min) {
            h = s = 0;
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        
        return { h: Math.round(h * 360), s: Math.round(s * 100), l: Math.round(l * 100) };
    }
    
    function hslToRgb(h, s, l) {
        h /= 360; s /= 100; l /= 100;
        let r, g, b;
        
        if (s === 0) {
            r = g = b = l;
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };
            
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }
        
        return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
    }
    
    function rgbToHex(r, g, b) {
        return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }
    
    function hexToHsl(hex) {
        const rgb = hexToRgb(hex);
        return rgbToHsl(rgb.r, rgb.g, rgb.b);
    }
    
    function hslToHex(h, s, l) {
        const rgb = hslToRgb(h, s, l);
        return rgbToHex(rgb.r, rgb.g, rgb.b);
    }
    
    function generateHarmony(baseColor, harmonyType) {
        const hsl = hexToHsl(baseColor);
        const { h, s, l } = hsl;
        let colors = [];
        
        switch (harmonyType) {
            case 'monochromatic':
                colors = [
                    hslToHex(h, s, l),
                    hslToHex(h, s * 0.7, l),
                    hslToHex(h, s, l * 0.8),
                    hslToHex(h, s * 0.7, Math.min(100, l * 1.2)),
                    hslToHex(h, Math.min(100, s * 1.3), l * 0.8),
                    hslToHex(h, Math.min(100, s * 1.3), Math.min(100, l * 1.2))
                ];
                break;
            case 'analogous':
                colors = [
                    hslToHex(h, s, l),
                    hslToHex((h + 30) % 360, s, l),
                    hslToHex((h + 60) % 360, s, l),
                    hslToHex((h - 30 + 360) % 360, s, l),
                    hslToHex((h - 60 + 360) % 360, s, l),
                    hslToHex(h, s * 0.8, Math.min(100, l * 1.2))
                ];
                break;
            case 'triadic':
                colors = [
                    hslToHex(h, s, l),
                    hslToHex((h + 120) % 360, s, l),
                    hslToHex((h + 240) % 360, s, l),
                    hslToHex(h, s * 0.8, Math.min(100, l * 1.2)),
                    hslToHex((h + 120) % 360, s * 0.8, Math.min(100, l * 1.2)),
                    hslToHex((h + 240) % 360, s * 0.8, Math.min(100, l * 1.2))
                ];
                break;
            case 'tetradic':
                colors = [
                    hslToHex(h, s, l),
                    hslToHex((h + 90) % 360, s, l),
                    hslToHex((h + 180) % 360, s, l),
                    hslToHex((h + 270) % 360, s, l),
                    hslToHex(h, s * 0.8, Math.min(100, l * 1.2)),
                    hslToHex((h + 180) % 360, s * 0.8, Math.min(100, l * 1.2))
                ];
                break;
            default:
                colors = [...DEFAULT_COLORS];
        }
        
        return colors;
    }
    
    // Sound Management Functions
    function populateSoundOptions() {
        const soundList = document.getElementById('soundList');
        const sounds = [
            { id: 'chimeSound', name: 'üîî Digital Chime', desc: 'Gentle electronic tone' },
            { id: 'bellSound', name: 'üîî Bell', desc: 'Classic bell ring' },
            { id: 'beepSound', name: 'üìØ Beep', desc: 'Short alert beep' },
            { id: 'alarmSound', name: '‚è∞ Alarm Clock', desc: 'Traditional alarm sound' },
            { id: 'notificationSound', name: 'üì¢ Notification', desc: 'Soft notification chord' }
        ];
        
        soundList.innerHTML = '';
        
        sounds.forEach(sound => {
            const option = document.createElement('div');
            option.className = `sound-option ${sound.id === selectedSound ? 'selected' : ''}`;
            option.setAttribute('data-sound-id', sound.id);
            option.innerHTML = `
                <div>
                    <div style="font-weight: 600;">${sound.name}</div>
                    <div style="font-size: 0.9rem; color: #666; margin-top: 5px;">${sound.desc}</div>
                </div>
                <button onclick="previewSound('${sound.id}')" class="btn-secondary" style="margin-left: auto; padding: 8px 15px;">Preview</button>
            `;
            
            option.addEventListener('click', function(e) {
                if (e.target.tagName !== 'BUTTON') {
                    selectSound(sound.id);
                }
            });
            
            soundList.appendChild(option);
        });
    }
    
    function openSoundModal() {
        document.getElementById('soundModal').style.display = 'block';
    }
    
    function previewSound(soundId) {
        playSound(soundId);
    }
    
    function selectSound(soundId) {
        selectedSound = soundId;
        localStorage.setItem('selectedSound', soundId);
        
        document.querySelectorAll('.sound-option').forEach(option => {
            option.classList.toggle('selected', option.getAttribute('data-sound-id') === soundId);
        });
        
        showNotification("üîä Sound updated!");
    }
    
    // Preset Management Functions
    function openPresetsModal() {
        document.getElementById('presetsModal').style.display = 'block';
        loadPresets();
    }
    
    // Quick Start Functions
    function openQuickStartModal() {
        document.getElementById('quickStartModal').style.display = 'block';
        renderQuickStartTemplates();
    }

    function renderQuickStartTemplates() {
        const container = document.getElementById('quickStartTemplates');
container.innerHTML = '';

Object.entries(PRESET_TEMPLATES).forEach(([name, template]) => {
    const totalDuration = template.activities.reduce((sum, act) => sum + act.duration, 0);
    
    const card = document.createElement('div');
    card.style.cssText = `
        background: linear-gradient(135deg, #f8f9ff 0%, #e8f4fd 100%);
        border: 2px solid #e1e5e9;
        border-radius: 20px;
        padding: 25px;
        cursor: pointer;
        transition: all 0.3s ease;
        text-align: center;
            `;
            
            card.innerHTML = `
        <div style="font-size: 3rem; margin-bottom: 15px;">${template.icon}</div>
        <div style="font-size: 1.3rem; font-weight: bold; color: #333; margin-bottom: 10px;">${name}</div>
        <div style="font-size: 0.9rem; color: #666; margin-bottom: 15px; min-height: 40px;">${template.description}</div>
        <div style="display: flex; justify-content: space-around; padding-top: 15px; border-top: 1px solid #e1e5e9;">
            <div style="text-align: center;">
                <div style="font-size: 1.5rem; font-weight: bold; color: #4facfe;">${template.activities.length}</div>
                <div style="font-size: 0.75rem; color: #999; text-transform: uppercase;">Activities</div>
            </div>
            <div style="text-align: center;">
                <div style="font-size: 1.5rem; font-weight: bold; color: #4facfe;">${totalDuration}</div>
                <div style="font-size: 0.75rem; color: #999; text-transform: uppercase;">Minutes</div>
            </div>
        </div>
            `;
            
            card.onmouseover = () => {
        card.style.transform = 'translateY(-5px)';
        card.style.boxShadow = '0 15px 35px rgba(102, 126, 234, 0.25)';
        card.style.borderColor = '#4facfe';
            };
            
            card.onmouseout = () => {
        card.style.transform = 'translateY(0)';
        card.style.boxShadow = 'none';
        card.style.borderColor = '#e1e5e9';
            };
            
            card.onclick = () => loadQuickStartTemplate(name, template);
            
            container.appendChild(card);
        });
    }

    function loadQuickStartTemplate(name, template) {
        // Track usage
        if (typeof gtag !== 'undefined') {
            gtag('event', 'quickstart_template_used', {
                'event_category': 'templates',
                'event_label': name
            });
        }
        
        // Warn if activities exist
        if (activities.length > 0) {
            if (!confirm(`Load "${name}" template? This will replace your current activities.`)) {
                return;
            }
            if (isRunning) resetTimer();
        }
        
        // Load activities from template
        activities = template.activities.map(act => ({
            name: act.name,
            duration: act.duration,
            color: act.color,
            completed: false,
            startTime: null,
            elapsedTime: 0,
            remainingTime: act.duration * 60
        }));
        
        updateActivityKey();
        updateClockDisplay();
        updateStats();
        closeModal('quickStartModal');
        
        showNotification(`‚ö° "${name}" loaded! Click START when ready.`);
    }
    
    // Preset Management Functions  
    function saveAsPreset() {
        if (activities.length === 0) {
            showNotification("‚ùå Please add at least one activity before saving a preset");
            return;
        }
        
        const presetName = document.getElementById('newPresetName').value.trim();
        if (!presetName) {
            showNotification("‚ùå Please enter a name for your preset");
            return;
        }
        
        try {
            let presets = {};
            if (localStorage.getItem('timerPresets')) {
                presets = JSON.parse(localStorage.getItem('timerPresets'));
            }
            
            const presetActivities = activities.map(act => ({
                name: act.name,
                duration: act.duration,
                color: act.color
            }));
            
            presets[presetName] = presetActivities;
            localStorage.setItem('timerPresets', JSON.stringify(presets));
            document.getElementById('newPresetName').value = '';
            loadPresets();
            
            showNotification(`‚úÖ Preset "${presetName}" saved successfully!`);
        } catch (error) {
            console.error("Error saving preset:", error);
            showNotification("‚ùå Could not save preset");
        }
    }
    
    function loadPresets() {
        const container = document.getElementById('presetContainer');
        const noPresetsMsg = document.getElementById('noPresetsMessage');
        
        try {
            const presets = JSON.parse(localStorage.getItem('timerPresets') || '{}');
            const presetNames = Object.keys(presets);
            
            if (presetNames.length === 0) {
                noPresetsMsg.style.display = 'block';
                container.innerHTML = '';
                container.appendChild(noPresetsMsg);
                return;
            }
            
            noPresetsMsg.style.display = 'none';
            container.innerHTML = '';
            
            presetNames.forEach(name => {
                const presetBox = document.createElement('div');
                presetBox.style.cssText = `
                    border: 2px solid #e1e5e9;
                    border-radius: 15px;
                    padding: 20px;
                    width: 200px;
                    text-align: center;
                    cursor: pointer;
                    position: relative;
                    background: linear-gradient(135deg, #f8f9ff 0%, #e8f4fd 100%);
                    transition: all 0.3s ease;
                    margin: 10px;
                `;
                
                const activitiesCount = presets[name].length;
                const totalDuration = presets[name].reduce((sum, act) => sum + act.duration, 0);
                
                presetBox.innerHTML = `
                    <h4 style="margin-bottom: 10px; color: #333;">${name}</h4>
                    <p style="color: #666; margin: 5px 0;">${activitiesCount} activities</p>
                    <p style="color: #666; margin: 5px 0;">Total: ${totalDuration} min</p>
                    <button onclick="deletePreset('${name}', event)" style="
                        position: absolute;
                        top: 8px;
                        right: 8px;
                        background: transparent;
                        border: none;
                        cursor: pointer;
                        font-weight: bold;
                        color: #999;
                        font-size: 18px;
                        width: 25px;
                        height: 25px;
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        transition: all 0.3s ease;
                    " onmouseover="this.style.color='#ff4757'; this.style.backgroundColor='rgba(255,71,87,0.1)'" onmouseout="this.style.color='#999'; this.style.backgroundColor='transparent'">√ó</button>
                `;
                
                presetBox.addEventListener('mouseover', () => {
                    presetBox.style.transform = 'translateY(-5px)';
                    presetBox.style.boxShadow = '0 15px 35px rgba(102, 126, 234, 0.2)';
                    presetBox.style.borderColor = '#4facfe';
                });
                
                presetBox.addEventListener('mouseout', () => {
                    presetBox.style.transform = 'translateY(0)';
                    presetBox.style.boxShadow = 'none';
                    presetBox.style.borderColor = '#e1e5e9';
                });
                
                presetBox.addEventListener('click', function(e) {
                    if (e.target.tagName !== 'BUTTON') {
                        loadPreset(name);
                    }
                });
                
                container.appendChild(presetBox);
            });
        } catch (error) {
            console.error("Error loading presets:", error);
            noPresetsMsg.style.display = 'block';
            container.innerHTML = '';
            container.appendChild(noPresetsMsg);
        }
    }
    
    function loadPreset(presetName) {
        try {
            const presets = JSON.parse(localStorage.getItem('timerPresets') || '{}');
            
            if (!presets[presetName]) {
                showNotification(`‚ùå Preset "${presetName}" not found`);
                return;
            }
            
            if (activities.length > 0) {
                if (!confirm(`Load preset "${presetName}"? This will replace your current activities.`)) {
                    return;
                }
            }
            
            resetTimer();
            
            activities = presets[presetName].map(act => ({
                ...act,
                completed: false,
                startTime: null,
                elapsedTime: 0,
                remainingTime: act.duration * 60
            }));
            
            updateActivityKey();
            updateClockDisplay();
            updateStats();
            closeModal('presetsModal');
            
            showNotification(`‚úÖ Preset "${presetName}" loaded successfully!`);
        } catch (error) {
            console.error("Error loading preset:", error);
            showNotification("‚ùå Could not load preset");
        }
    }
    
    function deletePreset(presetName, event) {
        event.stopPropagation();
        
        if (!confirm(`Delete preset "${presetName}"?`)) {
            return;
        }
        
        try {
            const presets = JSON.parse(localStorage.getItem('timerPresets') || '{}');
            
            if (presets[presetName]) {
                delete presets[presetName];
                localStorage.setItem('timerPresets', JSON.stringify(presets));
            }
            
            loadPresets();
            showNotification(`üóëÔ∏è Preset "${presetName}" deleted`);
        } catch (error) {
            console.error("Error deleting preset:", error);
            showNotification("‚ùå Could not delete preset");
        }
    }

    // Import/Export Functions
    function exportActivities() {
        if (activities.length === 0) {
            showNotification("‚ùå No activities to export");
            return;
        }
        
        try {
            const exportData = activities.map(act => ({
                name: act.name,
                duration: act.duration,
                color: act.color
            }));
            
            const jsonData = JSON.stringify(exportData, null, 2);
            const dataUri = "data:text/json;charset=utf-8," + encodeURIComponent(jsonData);
            
            const link = document.createElement('a');
            link.href = dataUri;
            link.download = `timer-activities-${new Date().toISOString().slice(0, 10)}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showNotification("üì§ Activities exported successfully!");
        } catch (error) {
            console.error("Error exporting activities:", error);
            showNotification("‚ùå Could not export activities");
        }
    }
    
    function importActivities() {
        try {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = e => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const importedData = JSON.parse(event.target.result);
                        
                        if (!Array.isArray(importedData)) {
                            throw new Error("Invalid import format: not an array");
                        }
                        
                        if (activities.length > 0) {
                            if (!confirm("This will replace your current activities. Continue?")) {
                                return;
                            }
                            resetTimer();
                        }
                        
                        activities = importedData.map(act => {
                            if (!act.name || typeof act.duration !== 'number') {
                                throw new Error("Invalid activity format");
                            }
                            
                            return {
                                name: act.name,
                                duration: act.duration,
                                color: act.color || colorPalette[0],
                                completed: false,
                                startTime: null,
                                elapsedTime: 0,
                                remainingTime: act.duration * 60
                            };
                        });
                        
                        updateActivityKey();
                        updateClockDisplay();
                        updateStats();
                        
                        showNotification("üì• Activities imported successfully!");
                    } catch (error) {
                        console.error("Error parsing import file:", error);
                        showNotification("‚ùå Error importing activities: " + error.message);
                    }
                };
                
                reader.readAsText(file);
            };
            
            input.click();
        } catch (error) {
            console.error("Error setting up import:", error);
            showNotification("‚ùå Could not import activities");
        }
    }

    // Session Summary Functions
    function showSummary() {
        const summaryModal = document.getElementById("summaryModal");
        const summaryList = document.getElementById("summaryList");
        const exportBtn = document.getElementById("exportSummaryBtn");
        const saveChartBtn = document.getElementById("saveChartBtn");
        const printBtn = document.getElementById("printSummaryBtn");
        
        summaryList.innerHTML = "";

        activities.forEach((act, i) => {
            const li = document.createElement("li");
            li.style.cssText = `
                display: flex;
                align-items: center;
                padding: 15px;
                margin: 10px 0;
                background: linear-gradient(135deg, #f8f9ff 0%, #e8f4fd 100%);
                border-radius: 12px;
                border-left: 4px solid ${act.color};
            `;
            
            const minutes = Math.floor((act.elapsedTime || 0) / 60);
            const seconds = (act.elapsedTime || 0) % 60;
            
            li.innerHTML = `
                <div style="width: 20px; height: 20px; background: ${act.color}; border-radius: 50%; margin-right: 15px; border: 2px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.2);"></div>
                <div style="flex: 1;">
                    <strong style="color: #333;">${act.name}</strong>
                    <div style="font-size: 0.9rem; color: #666; margin-top: 5px;">
                        Planned: ${act.duration} min | Actual: ${minutes}m ${seconds}s | 
                        <span style="color: ${act.completed ? '#4caf50' : '#ff4757'}; font-weight: 600;">
                            ${act.completed ? '‚úÖ Completed' : '‚ùå Incomplete'}
                        </span>
                    </div>
                </div>
            `;
            summaryList.appendChild(li);
        });

        exportBtn.onclick = exportSummary;
        saveChartBtn.onclick = saveChartAsImage;
        printBtn.onclick = printSummary;
        summaryModal.style.display = "block";

        // Create chart
        const ctx = document.getElementById("summaryChart").getContext("2d");
        const labels = activities.map(act => act.name);
        const plannedData = activities.map(act => act.duration);
        const actualData = activities.map(act => Math.round((act.elapsedTime || 0) / 60));
        
        if (window.summaryChart) window.summaryChart.destroy();
        window.summaryChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels,
                datasets: [
                    {
                        label: 'Planned (min)',
                        data: plannedData,
                        backgroundColor: activities.map(act => act.color + '80'),
                        borderColor: activities.map(act => act.color),
                        borderWidth: 2
                    },
                    {
                        label: 'Actual (min)',
                        data: actualData,
                        backgroundColor: activities.map(act => act.completed ? '#4caf50' : '#ff4757'),
                        borderColor: activities.map(act => act.completed ? '#388e3c' : '#d32f2f'),
                        borderWidth: 2
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: { 
                        display: true,
                        position: 'top',
                        labels: {
                            usePointStyle: true,
                            padding: 20
                        }
                    },
                    title: { 
                        display: true, 
                        text: 'Session Performance Overview',
                        font: {
                            size: 16,
                            weight: 'bold'
                        },
                        padding: 20
                    }
                },
                scales: {
                    y: { 
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Minutes'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Activities'
                        }
                    }
                }
            }
        });

        saveSessionToHistory();
    }

    function exportSummary() {
        const completedCount = activities.filter(act => act.completed).length;
        const totalCount = activities.length;
        const totalMinutes = activities.reduce((sum, act) => sum + act.duration, 0);
        const actualMinutes = activities.reduce((sum, act) => sum + Math.round((act.elapsedTime || 0) / 60), 0);

        const lines = [
            `üéØ TIMER SESSION SUMMARY`,
            `Generated: ${new Date().toLocaleString()}`,
            ``,
            `üìä OVERVIEW`,
            `Total Activities: ${totalCount}`,
            `Completed: ${completedCount} (${Math.round((completedCount/totalCount)*100)}%)`,
            `Total Time Planned: ${totalMinutes} minutes`,
            `Total Time Actual: ${actualMinutes} minutes`,
            
            ``,
            `üìã DETAILED BREAKDOWN`,
            `${'='.repeat(50)}`
        ];

        activities.forEach((act, index) => {
            const actualTime = act.elapsedTime || 0;
            const minutes = Math.floor(actualTime / 60);
            const seconds = actualTime % 60;
            
            lines.push(`${index + 1}. ${act.name}`);
            lines.push(`   Planned: ${act.duration} minutes`);
            lines.push(`   Actual: ${minutes}m ${seconds}s`);
            lines.push(`   Status: ${act.completed ? '‚úÖ Completed' : '‚ùå Incomplete'}`);
            lines.push('');
        });

        const blob = new Blob([lines.join('\n')], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);

        const link = document.createElement('a');
        link.href = url;
        link.download = `Timer_Session_Summary_${new Date().toISOString().slice(0, 10)}.txt`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        showNotification("üì§ Summary exported successfully!");
    }

    function saveChartAsImage() {
        const canvas = document.getElementById("summaryChart");
        const image = canvas.toDataURL("image/png");
        const link = document.createElement("a");
        link.href = image;
        link.download = `Timer_Performance_Chart_${new Date().toISOString().slice(0, 10)}.png`;
        link.click();
        
        showNotification("üñºÔ∏è Chart saved as image!");
    }

    function printSummary() {
        const printWindow = window.open('', '_blank');
        const chartImage = document.getElementById("summaryChart").toDataURL("image/png");
        const completedCount = activities.filter(act => act.completed).length;
        const totalCount = activities.length;

        let html = `
            <html>
            <head>
                <title>Timer Session Summary</title>
                <style>
                    body { font-family: Arial, sans-serif; margin: 40px; }
                    .header { text-align: center; margin-bottom: 30px; }
                    .stats { background: #f5f5f5; padding: 20px; border-radius: 10px; margin: 20px 0; }
                    .activity { margin: 15px 0; padding: 15px; border-left: 4px solid #4facfe; background: #f9f9f9; }
                    .chart { text-align: center; margin: 30px 0; }
                    @media print { .no-print { display: none; } }
                </style>
            </head>
            <body>
                <div class="header">
                    <h1>üéØ Timer Session Summary</h1>
                    <p>Generated: ${new Date().toLocaleString()}</p>
                </div>
                
                <div class="stats">
                    <h3>üìä Session Overview</h3>
                    <p><strong>Total Activities:</strong> ${totalCount}</p>
                    <p><strong>Completed:</strong> ${completedCount} (${Math.round((completedCount/totalCount)*100)}%)</p>
                    <p><strong>Success Rate:</strong> ${Math.round((completedCount/totalCount)*100)}%</p>
                </div>

                <h3>üìã Activity Details</h3>
        `;

        activities.forEach((act, index) => {
            const minutes = Math.floor((act.elapsedTime || 0) / 60);
            const seconds = (act.elapsedTime || 0) % 60;
            
            html += `
                <div class="activity" style="border-left-color: ${act.color};">
                    <h4>${index + 1}. ${act.name}</h4>
                    <p><strong>Planned:</strong> ${act.duration} minutes</p>
                    <p><strong>Actual:</strong> ${minutes}m ${seconds}s</p>
                    <p><strong>Status:</strong> ${act.completed ? '‚úÖ Completed' : '‚ùå Incomplete'}</p>
                </div>
            `;
        });

        html += `
                <div class="chart">
                    <h3>üìà Performance Chart</h3>
                    <img src="${chartImage}" style="max-width: 100%; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
                </div>
            </body>
            </html>
        `;

        printWindow.document.write(html);
        printWindow.document.close();
        printWindow.focus();
        setTimeout(() => {
            printWindow.print();
            printWindow.close();
        }, 500);
        
        showNotification("üñ®Ô∏è Summary sent to printer!");
    }

    function saveSessionToHistory() {
        const session = {
            timestamp: new Date().toISOString(),
            activities: activities.map(act => ({
                name: act.name,
                duration: act.duration,
                completed: act.completed,
                elapsedTime: act.elapsedTime || 0,
                color: act.color
            }))
        };

        const history = JSON.parse(localStorage.getItem('sessionHistory') || '[]');
        history.push(session);
        
        // Keep only last 50 sessions
        if (history.length > 50) {
            history.splice(0, history.length - 50);
        }
        
        localStorage.setItem('sessionHistory', JSON.stringify(history));
    }

    // Close modals when clicking outside
    window.onclick = function(event) {
        const modals = document.querySelectorAll('.modal');
        modals.forEach(modal => {
            if (event.target === modal) {
                modal.style.display = "none";
            }
        });
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', function(e) {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        
        switch(e.key) {
            case ' ':
                e.preventDefault();
                if (isRunning) {
                    pauseTimer();
                } else if (paused) {
                    resumeTimer();
                } else {
                    startTimer();
                }
                break;
            case 'r':
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    resetTimer();
                }
                break;
            case 's':
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    saveActivities();
                }
                break;
            case 'f':
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    toggleFocusMode();
                }
                break;
            case 'Escape':
                const openModal = document.querySelector('.modal[style*="block"]');
                if (openModal) {
                    openModal.style.display = 'none';
                }
                break;
        }
    });

    // Initialize insights rotation
    function rotateInsights() {
        const insights = [
            "üéØ Perfect timing to start your focused work session!",
            "‚ö° Your productivity peaks with timed activities.",
            "üìà Break tasks into 25-minute focused sessions.",
            "üß† Use breaks between activities to recharge.",
            "üéµ Try background music to enhance focus.",
            "üí™ Physical movement between tasks boosts energy.",
            "üìù Review completed tasks for motivation.",
            "üåü Celebrate small wins to maintain momentum.",
            "‚è∞ Consistent timing builds productive habits.",
            "üîÑ Regular breaks prevent mental fatigue.",
            "üíæ Your activity lists are automatically saved every 30 seconds.",
            "üì± This app works offline and syncs when connected.",
            "üé® Customize colors to match your workflow preferences."
        ];
        
        const insightsList = document.getElementById('insights-list');
        let currentInsightIndex = 0;
        
        setInterval(() => {
            if (insightsList && !isRunning) {
                const insight = insights[currentInsightIndex];
                insightsList.innerHTML = `
                    <div style="padding: 15px; background: linear-gradient(135deg, #f8f9ff 0%, #e8f4fd 100%); margin-bottom: 12px; border-radius: 12px; border-left: 4px solid #4facfe; font-size: 0.95rem; animation: fadeInUp 0.5s ease-out;">
                        ${insight}
                    </div>
                `;
                currentInsightIndex = (currentInsightIndex + 1) % insights.length;
            }
        }, 10000); // Rotate every 10 seconds
    }

    // Add fade-in animation to CSS
    const style = document.createElement('style');
    style.textContent = `
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    `;
    document.head.appendChild(style);

    // Start insights rotation after page load
    setTimeout(rotateInsights, 3000);

    // Auto-save activities every 30 seconds
    setInterval(() => {
        if (activities.length > 0) {
            saveActivities();
        }
    }, 30000);

    // Show welcome message
    setTimeout(() => {
        if (activities.length === 0) {
            showNotification("üëã Welcome! Add your first activity to get started!");
        }
    }, 1000);
</script>
```

</body>
</html>